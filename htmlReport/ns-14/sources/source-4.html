


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > GraphicGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.graphstream.ui.graphicGraph</a>
</div>

<h1>Coverage Summary for Class: GraphicGraph (org.graphstream.ui.graphicGraph)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GraphicGraph</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/368)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
&nbsp; * 
&nbsp; * GraphStream is a library whose purpose is to handle static or dynamic
&nbsp; * graph, create them from scratch, file or any source and display them.
&nbsp; * 
&nbsp; * This program is free software distributed under the terms of two licenses, the
&nbsp; * CeCILL-C license that fits European law, and the GNU Lesser General Public
&nbsp; * License. You can  use, modify and/ or redistribute the software under the terms
&nbsp; * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
&nbsp; * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or (at your
&nbsp; * option) any later version.
&nbsp; * 
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT ANY
&nbsp; * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
&nbsp; * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
&nbsp; * 
&nbsp; * You should have received a copy of the GNU Lesser General Public License
&nbsp; * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; * 
&nbsp; * The fact that you are presently reading this means that you have had
&nbsp; * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * @since 2009-07-05
&nbsp; * 
&nbsp; * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
&nbsp; * @author Antoine Dutot &lt;antoine.dutot@graphstream-project.org&gt;
&nbsp; * @author Yoann Pign√© &lt;yoann.pigne@graphstream-project.org&gt;
&nbsp; * @author Stefan Balev &lt;stefan.balev@graphstream-project.org&gt;
&nbsp; * @author Richard O. Legendi &lt;richard.legendi@gmail.com&gt;
&nbsp; * @author Alex Bowen &lt;bowen.a@gmail.com&gt;
&nbsp; * @author Ben Wiederhake &lt;BenWiederhake.GitHub@gmx&gt;
&nbsp; * @author kitskub &lt;kitskub@gmail.com&gt;
&nbsp; * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
&nbsp; */
&nbsp;package org.graphstream.ui.graphicGraph;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.graphstream.graph.Edge;
&nbsp;import org.graphstream.graph.EdgeFactory;
&nbsp;import org.graphstream.graph.Element;
&nbsp;import org.graphstream.graph.ElementNotFoundException;
&nbsp;import org.graphstream.graph.Graph;
&nbsp;import org.graphstream.graph.IdAlreadyInUseException;
&nbsp;import org.graphstream.graph.Node;
&nbsp;import org.graphstream.graph.NodeFactory;
&nbsp;import org.graphstream.graph.implementations.AbstractElement;
&nbsp;import org.graphstream.stream.AttributeSink;
&nbsp;import org.graphstream.stream.ElementSink;
&nbsp;import org.graphstream.stream.Sink;
&nbsp;import org.graphstream.stream.SourceBase.ElementType;
&nbsp;import org.graphstream.stream.file.FileSink;
&nbsp;import org.graphstream.stream.file.FileSource;
&nbsp;import org.graphstream.ui.geom.Point3;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.Style;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleConstants;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleConstants.Units;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleSheet;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.Value;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.Values;
&nbsp;import org.graphstream.ui.view.Viewer;
&nbsp;import org.graphstream.util.GraphListeners;
&nbsp;
&nbsp;/**
&nbsp; * Graph representation used in display classes.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Warning: This class is NOT a general graph class, and it should NOT be used
&nbsp; * as it. This class is particularly dedicated to fast drawing of the graph and
&nbsp; * is internally arranged to be fast for this task only. It implements graph
&nbsp; * solely to be easily susceptible to be used as a sink and source for graph
&nbsp; * events. Some of the common methods of the Graph interface are not functional
&nbsp; * and will throw an exception if used (as documented in their respective
&nbsp; * JavaDoc).
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The purpose of the graphic graph is to represent a graph with some often used
&nbsp; * graphic attributes (like position, label, etc.) stored as fields in the nodes
&nbsp; * and edges and most of the style stored in styles pertaining to a style sheet
&nbsp; * that tries to imitate the way CSS works. For example, the GraphicNode class
&nbsp; * defines a label, a position (x,y,z) and a style that is taken from the style
&nbsp; * sheet.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The style sheet is uploaded on the graph using an attribute correspondingly
&nbsp; * named &quot;stylesheet&quot; or &quot;ui.stylesheet&quot; (the second one is better). It can be a
&nbsp; * string that contains the whole style sheet, or an URL of the form :
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * 
&nbsp; * &lt;pre&gt;
&nbsp; * url(name)
&nbsp; * &lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The graphic graph does not completely duplicate a graph, it only store things
&nbsp; * that are useful for drawing it. Although it implements &quot;Graph&quot;, some methods
&nbsp; * are not implemented and will throw a runtime exception. These methods are
&nbsp; * mostly utility methods like write(), read(), and naturally display().
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The graphic graph has the ability to store attributes like any other graph
&nbsp; * element, however the attributes stored by the graphic graph are restricted.
&nbsp; * There is a filter on the attribute adding methods that let pass only:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;All attributes starting with &quot;ui.&quot;.&lt;/li&gt;
&nbsp; * &lt;li&gt;The &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;xy&quot; and &quot;xyz&quot; attributes.&lt;/li&gt;
&nbsp; * &lt;li&gt;The &quot;stylesheet&quot; attribute (although &quot;ui.stylesheet&quot; is preferred).&lt;/li&gt;
&nbsp; * &lt;li&gt;The &quot;label&quot; attribute.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * All other attributes are filtered and not stored. The result is that if the
&nbsp; * graphic graph is used as an input (a source of graph events) some attributes
&nbsp; * will not pass through the filter.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The implementation of this graph relies on the StyleGroupSet class and this
&nbsp; * is indeed its way to store its elements (grouped by style and Z level).
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * In addition to this, it provides, as all graphs do, the relational
&nbsp; * information for edges.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * TODO : this graph cannot handle modification inside event listener methods !!
&nbsp; */
<b class="nc">&nbsp;public class GraphicGraph extends AbstractElement implements Graph, StyleGroupListener {</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * class level logger
&nbsp;	 */
<b class="nc">&nbsp;	private static final Logger logger = Logger.getLogger(GraphicGraph.class.getSimpleName());</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of styles.
&nbsp;	 */
&nbsp;	protected StyleSheet styleSheet;
&nbsp;
&nbsp;	/**
&nbsp;	 * Associate graphic elements with styles.
&nbsp;	 */
&nbsp;	protected StyleGroupSet styleGroups;
&nbsp;
&nbsp;	/**
&nbsp;	 * Connectivity. The way nodes are connected one with another via edges. The map
&nbsp;	 * is sorted by node. For each node an array of edges lists the connectivity.
&nbsp;	 */
&nbsp;	protected final Map&lt;GraphicNode, List&lt;GraphicEdge&gt;&gt; connectivity;
&nbsp;
&nbsp;	/**
&nbsp;	 * The style of this graph. This is a shortcut to avoid searching it in the
&nbsp;	 * style sheet.
&nbsp;	 */
&nbsp;	public StyleGroup style;
&nbsp;
&nbsp;	/**
&nbsp;	 * Memorize the step events.
&nbsp;	 */
<b class="nc">&nbsp;	public double step = 0;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Set to true each time the graph was modified internally and a redraw is
&nbsp;	 * needed.
&nbsp;	 */
&nbsp;	public boolean graphChanged;
&nbsp;
&nbsp;	/**
&nbsp;	 * Set to true each time a sprite or node moved.
&nbsp;	 */
<b class="nc">&nbsp;	protected boolean boundsChanged = true;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Maximum position of a node or sprite in the graphic graph. Computed by
&nbsp;	 * {@link #computeBounds()}.
&nbsp;	 */
<b class="nc">&nbsp;	protected Point3 hi = new Point3();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Minimum position of a node or sprite in the graphic graph. Computed by
&nbsp;	 * {@link #computeBounds()}.
&nbsp;	 */
<b class="nc">&nbsp;	protected Point3 lo = new Point3();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of listeners of this graph.
&nbsp;	 */
&nbsp;	protected GraphListeners listeners;
&nbsp;
&nbsp;	/**
&nbsp;	 * Time of other known sources.
&nbsp;	 */
&nbsp;	// protected SinkTime sinkTime = new SinkTime();
&nbsp;
&nbsp;	/**
&nbsp;	 * Report back the XYZ events on nodes and sprites? If enabled, each change in
&nbsp;	 * the position of nodes and sprites will be sent to potential listeners of the
&nbsp;	 * graph. By default this is disabled as long there are no listeners.
&nbsp;	 */
<b class="nc">&nbsp;	protected boolean feedbackXYZ = true;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * New empty graphic graph.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * A default style sheet is created, it then can be &quot;cascaded&quot; with other style
&nbsp;	 * sheets.
&nbsp;	 */
&nbsp;	public GraphicGraph(String id) {
<b class="nc">&nbsp;		super(id);</b>
&nbsp;
<b class="nc">&nbsp;		listeners = new GraphListeners(this);</b>
<b class="nc">&nbsp;		styleSheet = new StyleSheet();</b>
<b class="nc">&nbsp;		styleGroups = new StyleGroupSet(styleSheet);</b>
<b class="nc">&nbsp;		connectivity = new HashMap&lt;GraphicNode, List&lt;GraphicEdge&gt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		styleGroups.addListener(this);</b>
<b class="nc">&nbsp;		styleGroups.addElement(this); // Add style to this graph.</b>
&nbsp;
<b class="nc">&nbsp;		style = styleGroups.getStyleFor(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Access
&nbsp;
&nbsp;	/**
&nbsp;	 * True if the graph was edited or changed in any way since the last reset of
&nbsp;	 * the &quot;changed&quot; flag.
&nbsp;	 *
&nbsp;	 * @return true if the graph was changed.
&nbsp;	 */
&nbsp;	public boolean graphChangedFlag() {
<b class="nc">&nbsp;		return graphChanged;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reset the &quot;changed&quot; flag.
&nbsp;	 *
&nbsp;	 * @see #graphChangedFlag()
&nbsp;	 */
&nbsp;	public void resetGraphChangedFlag() {
<b class="nc">&nbsp;		graphChanged = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The style sheet. This style sheet is the result of the &quot;cascade&quot; or
&nbsp;	 * accumulation of styles added via attributes of the graph.
&nbsp;	 *
&nbsp;	 * @return A style sheet.
&nbsp;	 */
&nbsp;	public StyleSheet getStyleSheet() {
<b class="nc">&nbsp;		return styleSheet;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The graph style group.
&nbsp;	 *
&nbsp;	 * @return A style group.
&nbsp;	 */
&nbsp;	public StyleGroup getStyle() {
<b class="nc">&nbsp;		return style;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The complete set of style groups.
&nbsp;	 *
&nbsp;	 * @return The style groups.
&nbsp;	 */
&nbsp;	public StyleGroupSet getStyleGroups() {
<b class="nc">&nbsp;		return styleGroups;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		return String.format(&quot;[%s %d nodes %d edges]&quot;, getId(), getNodeCount(), getEdgeCount());</b>
&nbsp;	}
&nbsp;
&nbsp;	public double getStep() {
<b class="nc">&nbsp;		return step;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The maximum position of a node or sprite. Notice that this is updated only
&nbsp;	 * each time the {@link #computeBounds()} method is called.
&nbsp;	 *
&nbsp;	 * @return The maximum node or sprite position.
&nbsp;	 */
&nbsp;	public Point3 getMaxPos() {
<b class="nc">&nbsp;		return hi;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The minimum position of a node or sprite. Notice that this is updated only
&nbsp;	 * each time the {@link #computeBounds()} method is called.
&nbsp;	 *
&nbsp;	 * @return The minimum node or sprite position.
&nbsp;	 */
&nbsp;	public Point3 getMinPos() {
<b class="nc">&nbsp;		return lo;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Does the graphic graph publish via attribute changes the XYZ changes on nodes
&nbsp;	 * and sprites when changed ?. This is disabled by default, and enabled as soon
&nbsp;	 * as there is at least one listener.
&nbsp;	 */
&nbsp;	public boolean feedbackXYZ() {
<b class="nc">&nbsp;		return feedbackXYZ;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Command
&nbsp;
&nbsp;	/**
&nbsp;	 * Should the graphic graph publish via attribute changes the XYZ changes on
&nbsp;	 * nodes and sprites when changed ?.
&nbsp;	 */
&nbsp;	public void feedbackXYZ(boolean on) {
<b class="nc">&nbsp;		feedbackXYZ = on;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Compute the overall bounds of the graphic graph according to the nodes and
&nbsp;	 * sprites positions. We can only compute the graph bounds from the nodes and
&nbsp;	 * sprites centres since the node and graph bounds may in certain circumstances
&nbsp;	 * be computed according to the graph bounds. The bounds are stored in the graph
&nbsp;	 * metrics.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This operation will process each node and sprite and is therefore costly.
&nbsp;	 * However it does this computation again only when a node or sprite moved.
&nbsp;	 * Therefore it can be called several times, if nothing moved in the graph, the
&nbsp;	 * computation will not be redone.
&nbsp;	 *
&nbsp;	 * @see #getMaxPos()
&nbsp;	 * @see #getMinPos()
&nbsp;	 */
&nbsp;	public void computeBounds() {
<b class="nc">&nbsp;		if (boundsChanged) {</b>
<b class="nc">&nbsp;			final AtomicBoolean effectiveChange = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;			lo.x = lo.y = lo.z = Double.MAX_VALUE;</b>
<b class="nc">&nbsp;			hi.x = hi.y = hi.z = -Double.MAX_VALUE;</b>
&nbsp;
<b class="nc">&nbsp;			nodes().forEach(n -&gt; {</b>
<b class="nc">&nbsp;				GraphicNode node = (GraphicNode) n;</b>
&nbsp;
<b class="nc">&nbsp;				if (!node.hidden &amp;&amp; node.positionned) {</b>
<b class="nc">&nbsp;					effectiveChange.set(true);</b>
&nbsp;
<b class="nc">&nbsp;					if (node.x &lt; lo.x)</b>
<b class="nc">&nbsp;						lo.x = node.x;</b>
<b class="nc">&nbsp;					if (node.x &gt; hi.x)</b>
<b class="nc">&nbsp;						hi.x = node.x;</b>
<b class="nc">&nbsp;					if (node.y &lt; lo.y)</b>
<b class="nc">&nbsp;						lo.y = node.y;</b>
<b class="nc">&nbsp;					if (node.y &gt; hi.y)</b>
<b class="nc">&nbsp;						hi.y = node.y;</b>
<b class="nc">&nbsp;					if (node.z &lt; lo.z)</b>
<b class="nc">&nbsp;						lo.z = node.z;</b>
<b class="nc">&nbsp;					if (node.z &gt; hi.z)</b>
<b class="nc">&nbsp;						hi.z = node.z;</b>
&nbsp;				}
&nbsp;			});
&nbsp;
<b class="nc">&nbsp;			sprites().forEach(sprite -&gt; {</b>
<b class="nc">&nbsp;				if (!sprite.isAttached() &amp;&amp; sprite.getUnits() == StyleConstants.Units.GU) {</b>
<b class="nc">&nbsp;					double x = sprite.getX();</b>
<b class="nc">&nbsp;					double y = sprite.getY();</b>
<b class="nc">&nbsp;					double z = sprite.getZ();</b>
&nbsp;
<b class="nc">&nbsp;					if (!sprite.hidden) {</b>
<b class="nc">&nbsp;						effectiveChange.set(true);</b>
&nbsp;
<b class="nc">&nbsp;						if (x &lt; lo.x)</b>
<b class="nc">&nbsp;							lo.x = x;</b>
<b class="nc">&nbsp;						if (x &gt; hi.x)</b>
<b class="nc">&nbsp;							hi.x = x;</b>
<b class="nc">&nbsp;						if (y &lt; lo.y)</b>
<b class="nc">&nbsp;							lo.y = y;</b>
<b class="nc">&nbsp;						if (y &gt; hi.y)</b>
<b class="nc">&nbsp;							hi.y = y;</b>
<b class="nc">&nbsp;						if (z &lt; lo.z)</b>
<b class="nc">&nbsp;							lo.z = z;</b>
<b class="nc">&nbsp;						if (z &gt; hi.z)</b>
<b class="nc">&nbsp;							hi.z = z;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			});
&nbsp;
<b class="nc">&nbsp;			if (hi.x - lo.x &lt; 0.000001) {</b>
<b class="nc">&nbsp;				hi.x = hi.x + 1;</b>
<b class="nc">&nbsp;				lo.x = lo.x - 1;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (hi.y - lo.y &lt; 0.000001) {</b>
<b class="nc">&nbsp;				hi.y = hi.y + 1;</b>
<b class="nc">&nbsp;				lo.y = lo.y - 1;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (hi.z - lo.z &lt; 0.000001) {</b>
<b class="nc">&nbsp;				hi.z = hi.z + 1;</b>
<b class="nc">&nbsp;				lo.z = lo.z - 1;</b>
&nbsp;			}
&nbsp;
&nbsp;			//
&nbsp;			// Prevent infinities that can be produced by Double.MAX_VALUE.
&nbsp;			//
<b class="nc">&nbsp;			if (effectiveChange.get())</b>
<b class="nc">&nbsp;				boundsChanged = false;</b>
&nbsp;			else {
<b class="nc">&nbsp;				lo.x = lo.y = lo.z = -1;</b>
<b class="nc">&nbsp;				hi.x = hi.y = hi.z = 1;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected void moveNode(String id, double x, double y, double z) {
<b class="nc">&nbsp;		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (node != null) {</b>
<b class="nc">&nbsp;			node.x = x;</b>
<b class="nc">&nbsp;			node.y = y;</b>
<b class="nc">&nbsp;			node.z = z;</b>
<b class="nc">&nbsp;			node.setAttribute(&quot;x&quot;, x);</b>
<b class="nc">&nbsp;			node.setAttribute(&quot;y&quot;, y);</b>
<b class="nc">&nbsp;			node.setAttribute(&quot;z&quot;, z);</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Node getNode(String id) {
<b class="nc">&nbsp;		return styleGroups.getNode(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge getEdge(String id) {
<b class="nc">&nbsp;		return styleGroups.getEdge(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	public GraphicSprite getSprite(String id) {
<b class="nc">&nbsp;		return styleGroups.getSprite(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void attributeChanged(AttributeChangeEvent event, String attribute, Object oldValue, Object newValue) {
&nbsp;
&nbsp;		// One of the most important method. Most of the communication comes
&nbsp;		// from attributes.
&nbsp;
<b class="nc">&nbsp;		if (attribute.equals(&quot;ui.repaint&quot;)) {</b>
<b class="nc">&nbsp;			graphChanged = true;</b>
<b class="nc">&nbsp;		} else if (attribute.equals(&quot;ui.stylesheet&quot;) || attribute.equals(&quot;stylesheet&quot;)) {</b>
<b class="nc">&nbsp;			if (event == AttributeChangeEvent.ADD || event == AttributeChangeEvent.CHANGE) {</b>
<b class="nc">&nbsp;				if (newValue instanceof String) {</b>
&nbsp;					try {
<b class="nc">&nbsp;						styleSheet.load((String) newValue);</b>
<b class="nc">&nbsp;						graphChanged = true;</b>
<b class="nc">&nbsp;					} catch (Exception e) {</b>
<b class="nc">&nbsp;						logger.log(Level.WARNING,</b>
<b class="nc">&nbsp;								String.format(&quot;Error while parsing style sheet for graph &#39;%s&#39;.&quot;, getId()), e);</b>
<b class="nc">&nbsp;					}</b>
&nbsp;				} else {
<b class="nc">&nbsp;					logger.warning(</b>
<b class="nc">&nbsp;							String.format(&quot;Error with stylesheet specification what to do with &#39;%s&#39;.&quot;, newValue));</b>
&nbsp;				}
&nbsp;			} else // Remove the style.
&nbsp;			{
<b class="nc">&nbsp;				styleSheet.clear();</b>
<b class="nc">&nbsp;				graphChanged = true;</b>
&nbsp;			}
<b class="nc">&nbsp;		} else if (attribute.startsWith(&quot;ui.sprite.&quot;)) {</b>
&nbsp;			// Defers the sprite handling to the sprite API.
<b class="nc">&nbsp;			spriteAttribute(event, null, attribute, newValue);</b>
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		listeners.sendAttributeChangedEvent(getId(), ElementType.GRAPH, attribute, event, oldValue, newValue);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Display the node/edge relations.
&nbsp;	 */
&nbsp;	public void printConnectivity() {
<b class="nc">&nbsp;		Iterator&lt;GraphicNode&gt; keys = connectivity.keySet().iterator();</b>
&nbsp;
<b class="nc">&nbsp;		System.err.printf(&quot;Graphic graph connectivity:%n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		while (keys.hasNext()) {</b>
<b class="nc">&nbsp;			GraphicNode node = keys.next();</b>
<b class="nc">&nbsp;			System.err.printf(&quot;    [%s] -&gt; &quot;, node.getId());</b>
<b class="nc">&nbsp;			Iterable&lt;GraphicEdge&gt; edges = connectivity.get(node);</b>
<b class="nc">&nbsp;			for (GraphicEdge edge : edges)</b>
<b class="nc">&nbsp;				System.err.printf(&quot; (%s %d)&quot;, edge.getId(), edge.getMultiIndex());</b>
<b class="nc">&nbsp;			System.err.printf(&quot;%n&quot;);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	// Style group listener interface
&nbsp;
&nbsp;	public void elementStyleChanged(Element element, StyleGroup oldStyle, StyleGroup style) {
<b class="nc">&nbsp;		if (element instanceof GraphicElement) {</b>
<b class="nc">&nbsp;			GraphicElement ge = (GraphicElement) element;</b>
<b class="nc">&nbsp;			ge.style = style;</b>
<b class="nc">&nbsp;			graphChanged = true;</b>
<b class="nc">&nbsp;		} else if (element instanceof GraphicGraph) {</b>
<b class="nc">&nbsp;			GraphicGraph gg = (GraphicGraph) element;</b>
<b class="nc">&nbsp;			gg.style = style;</b>
<b class="nc">&nbsp;			graphChanged = true;</b>
<b class="nc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			throw new RuntimeException(&quot;WTF ?&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void styleChanged(StyleGroup style) {
&nbsp;
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	// Graph interface
&nbsp;
&nbsp;	@Override
&nbsp;	public Stream&lt;Node&gt; nodes() {
<b class="nc">&nbsp;		return styleGroups.nodes();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Stream&lt;Edge&gt; edges() {
<b class="nc">&nbsp;		return styleGroups.edges();</b>
&nbsp;	}
&nbsp;
&nbsp;	public Stream&lt;GraphicSprite&gt; sprites() {
<b class="nc">&nbsp;		return styleGroups.sprites();</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;	public Iterator&lt;Node&gt; iterator() {
<b class="nc">&nbsp;		return (Iterator&lt;Node&gt;) styleGroups.getNodeIterator();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#addSink(org.graphstream.stream.Sink)
&nbsp;	 */
&nbsp;	public void addSink(Sink listener) {
<b class="nc">&nbsp;		listeners.addSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#removeSink(org.graphstream.stream.Sink)
&nbsp;	 */
&nbsp;	public void removeSink(Sink listener) {
<b class="nc">&nbsp;		listeners.removeSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#addAttributeSink(org.graphstream.stream
&nbsp;	 * .AttributeSink)
&nbsp;	 */
&nbsp;	public void addAttributeSink(AttributeSink listener) {
<b class="nc">&nbsp;		listeners.addAttributeSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#removeAttributeSink(org.graphstream.stream
&nbsp;	 * .AttributeSink)
&nbsp;	 */
&nbsp;	public void removeAttributeSink(AttributeSink listener) {
<b class="nc">&nbsp;		listeners.removeAttributeSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#addElementSink(org.graphstream.stream.
&nbsp;	 * ElementSink)
&nbsp;	 */
&nbsp;	public void addElementSink(ElementSink listener) {
<b class="nc">&nbsp;		listeners.addElementSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#removeElementSink(org.graphstream.stream
&nbsp;	 * .ElementSink)
&nbsp;	 */
&nbsp;	public void removeElementSink(ElementSink listener) {
<b class="nc">&nbsp;		listeners.removeElementSink(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#attributeSinks()
&nbsp;	 */
&nbsp;	public Iterable&lt;AttributeSink&gt; attributeSinks() {
<b class="nc">&nbsp;		return listeners.attributeSinks();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#elementSinks()
&nbsp;	 */
&nbsp;	public Iterable&lt;ElementSink&gt; elementSinks() {
<b class="nc">&nbsp;		return listeners.elementSinks();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#addEdge(java.lang.String, java.lang.String,
&nbsp;	 * java.lang.String, boolean)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public Edge addEdge(String id, String from, String to, boolean directed)
&nbsp;			throws IdAlreadyInUseException, ElementNotFoundException {
<b class="nc">&nbsp;		GraphicEdge edge = (GraphicEdge) styleGroups.getEdge(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (edge == null) {</b>
<b class="nc">&nbsp;			GraphicNode n1 = (GraphicNode) styleGroups.getNode(from);</b>
<b class="nc">&nbsp;			GraphicNode n2 = (GraphicNode) styleGroups.getNode(to);</b>
&nbsp;
<b class="nc">&nbsp;			if (n1 == null)</b>
<b class="nc">&nbsp;				throw new ElementNotFoundException(&quot;node \&quot;%s\&quot;&quot;, from);</b>
&nbsp;
<b class="nc">&nbsp;			if (n2 == null)</b>
<b class="nc">&nbsp;				throw new ElementNotFoundException(&quot;node \&quot;%s\&quot;&quot;, to);</b>
&nbsp;
<b class="nc">&nbsp;			edge = new GraphicEdge(id, n1, n2, directed, null);// , attributes);</b>
&nbsp;
<b class="nc">&nbsp;			styleGroups.addElement(edge);</b>
&nbsp;
<b class="nc">&nbsp;			List&lt;GraphicEdge&gt; l1 = connectivity.get(n1);</b>
<b class="nc">&nbsp;			List&lt;GraphicEdge&gt; l2 = connectivity.get(n2);</b>
&nbsp;
<b class="nc">&nbsp;			if (l1 == null) {</b>
<b class="nc">&nbsp;				l1 = new ArrayList&lt;GraphicEdge&gt;();</b>
<b class="nc">&nbsp;				connectivity.put(n1, l1);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (l2 == null) {</b>
<b class="nc">&nbsp;				l2 = new ArrayList&lt;GraphicEdge&gt;();</b>
<b class="nc">&nbsp;				connectivity.put(n2, l2);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			l1.add(edge);</b>
<b class="nc">&nbsp;			l2.add(edge);</b>
<b class="nc">&nbsp;			edge.countSameEdges(l1);</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;
<b class="nc">&nbsp;			listeners.sendEdgeAdded(id, from, to, directed);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return edge;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#addNode(java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public Node addNode(String id) throws IdAlreadyInUseException {
<b class="nc">&nbsp;		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (node == null) {</b>
<b class="nc">&nbsp;			node = new GraphicNode(this, id, null);// , attributes);</b>
&nbsp;
<b class="nc">&nbsp;			styleGroups.addElement(node);</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;
<b class="nc">&nbsp;			listeners.sendNodeAdded(id);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return node;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#clear()
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void clear() {
<b class="nc">&nbsp;		listeners.sendGraphCleared();</b>
&nbsp;
<b class="nc">&nbsp;		clearAttributesWithNoEvent();</b>
&nbsp;
<b class="nc">&nbsp;		connectivity.clear();</b>
<b class="nc">&nbsp;		styleGroups.clear();</b>
<b class="nc">&nbsp;		styleSheet.clear();</b>
&nbsp;
<b class="nc">&nbsp;		step = 0;</b>
<b class="nc">&nbsp;		graphChanged = true;</b>
&nbsp;
<b class="nc">&nbsp;		styleGroups.addElement(this);</b>
<b class="nc">&nbsp;		style = styleGroups.getStyleFor(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#removeEdge(java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public Edge removeEdge(String id) throws ElementNotFoundException {
<b class="nc">&nbsp;		GraphicEdge edge = (GraphicEdge) styleGroups.getEdge(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (edge != null) {</b>
<b class="nc">&nbsp;			listeners.sendEdgeRemoved(id);</b>
&nbsp;
<b class="nc">&nbsp;			if (connectivity.get(edge.from) != null)</b>
<b class="nc">&nbsp;				connectivity.get(edge.from).remove(edge);</b>
<b class="nc">&nbsp;			if (connectivity.get(edge.to) != null)</b>
<b class="nc">&nbsp;				connectivity.get(edge.to).remove(edge);</b>
&nbsp;
<b class="nc">&nbsp;			styleGroups.removeElement(edge);</b>
<b class="nc">&nbsp;			edge.removed();</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return edge;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#removeEdge(java.lang.String,
&nbsp;	 * java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public Edge removeEdge(String from, String to) throws ElementNotFoundException {
<b class="nc">&nbsp;		GraphicNode node0 = (GraphicNode) styleGroups.getNode(from);</b>
<b class="nc">&nbsp;		GraphicNode node1 = (GraphicNode) styleGroups.getNode(to);</b>
&nbsp;
<b class="nc">&nbsp;		if (node0 != null &amp;&amp; node1 != null) {</b>
<b class="nc">&nbsp;			Collection&lt;GraphicEdge&gt; edges0 = connectivity.get(node0);</b>
<b class="nc">&nbsp;			Collection&lt;GraphicEdge&gt; edges1 = connectivity.get(node1);</b>
&nbsp;
<b class="nc">&nbsp;			for (GraphicEdge edge0 : edges0) {</b>
<b class="nc">&nbsp;				for (GraphicEdge edge1 : edges1) {</b>
<b class="nc">&nbsp;					if (edge0 == edge1) {</b>
<b class="nc">&nbsp;						removeEdge(edge0.getId());</b>
<b class="nc">&nbsp;						return edge0;</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#removeNode(java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public Node removeNode(String id) throws ElementNotFoundException {
<b class="nc">&nbsp;		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (node != null) {</b>
<b class="nc">&nbsp;			listeners.sendNodeRemoved(id);</b>
&nbsp;
<b class="nc">&nbsp;			if (connectivity.get(node) != null) {</b>
&nbsp;				// We must do a copy of the connectivity set for the node
&nbsp;				// since we will be modifying the connectivity as we process
&nbsp;				// edges.
<b class="nc">&nbsp;				List&lt;GraphicEdge&gt; l = new ArrayList&lt;GraphicEdge&gt;(connectivity.get(node));</b>
&nbsp;
<b class="nc">&nbsp;				for (GraphicEdge edge : l)</b>
<b class="nc">&nbsp;					removeEdge(edge.getId());</b>
&nbsp;
<b class="nc">&nbsp;				connectivity.remove(node);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			styleGroups.removeElement(node);</b>
<b class="nc">&nbsp;			node.removed();</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return node;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Viewer display() {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph is used by display() and cannot recursively define display()&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Viewer display(boolean autoLayout) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph is used by display() and cannot recursively define display()&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.graph.Graph#stepBegins(double)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void stepBegins(double step) {
<b class="nc">&nbsp;		listeners.sendStepBegins(step);</b>
<b class="nc">&nbsp;		this.step = step;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public EdgeFactory&lt;? extends Edge&gt; edgeFactory() {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support EdgeFactory&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getEdgeCount() {
<b class="nc">&nbsp;		return styleGroups.getEdgeCount();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getNodeCount() {
<b class="nc">&nbsp;		return styleGroups.getNodeCount();</b>
&nbsp;	}
&nbsp;
&nbsp;	public int getSpriteCount() {
<b class="nc">&nbsp;		return styleGroups.getSpriteCount();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isAutoCreationEnabled() {
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public NodeFactory&lt;? extends Node&gt; nodeFactory() {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support NodeFactory&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setAutoCreate(boolean on) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support auto-creation&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isStrict() {
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setStrict(boolean on) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support strict checking&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setEdgeFactory(EdgeFactory&lt;? extends Edge&gt; ef) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;you cannot change the edge factory for graphic graphs !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setNodeFactory(NodeFactory&lt;? extends Node&gt; nf) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;you cannot change the node factory for graphic graphs !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void read(String filename) throws IOException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void read(FileSource input, String filename) throws IOException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void write(FileSink output, String filename) throws IOException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void write(String filename) throws IOException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Output interface
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#edgeAttributeAdded(java.lang.String,
&nbsp;	 * long, java.lang.String, java.lang.String, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void edgeAttributeAdded(String sourceId, long timeId, String edgeId, String attribute, Object value) {
<b class="nc">&nbsp;		listeners.edgeAttributeAdded(sourceId, timeId, edgeId, attribute, value);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#edgeAttributeChanged(java.lang.String ,
&nbsp;	 * long, java.lang.String, java.lang.String, java.lang.Object, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void edgeAttributeChanged(String sourceId, long timeId, String edgeId, String attribute, Object oldValue,
&nbsp;			Object newValue) {
<b class="nc">&nbsp;		listeners.edgeAttributeChanged(sourceId, timeId, edgeId, attribute, oldValue, newValue);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#edgeAttributeRemoved(java.lang.String ,
&nbsp;	 * long, java.lang.String, java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void edgeAttributeRemoved(String sourceId, long timeId, String edgeId, String attribute) {
<b class="nc">&nbsp;		listeners.edgeAttributeRemoved(sourceId, timeId, edgeId, attribute);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#graphAttributeAdded(java.lang.String ,
&nbsp;	 * long, java.lang.String, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void graphAttributeAdded(String sourceId, long timeId, String attribute, Object value) {
<b class="nc">&nbsp;		listeners.graphAttributeAdded(sourceId, timeId, attribute, value);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.AttributeSink#graphAttributeChanged(java.lang.
&nbsp;	 * String, long, java.lang.String, java.lang.Object, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void graphAttributeChanged(String sourceId, long timeId, String attribute, Object oldValue,
&nbsp;			Object newValue) {
<b class="nc">&nbsp;		listeners.graphAttributeChanged(sourceId, timeId, attribute, oldValue, newValue);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.AttributeSink#graphAttributeRemoved(java.lang.
&nbsp;	 * String, long, java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void graphAttributeRemoved(String sourceId, long timeId, String attribute) {
<b class="nc">&nbsp;		listeners.graphAttributeRemoved(sourceId, timeId, attribute);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#nodeAttributeAdded(java.lang.String,
&nbsp;	 * long, java.lang.String, java.lang.String, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void nodeAttributeAdded(String sourceId, long timeId, String nodeId, String attribute, Object value) {
<b class="nc">&nbsp;		listeners.nodeAttributeAdded(sourceId, timeId, nodeId, attribute, value);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#nodeAttributeChanged(java.lang.String ,
&nbsp;	 * long, java.lang.String, java.lang.String, java.lang.Object, java.lang.Object)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void nodeAttributeChanged(String sourceId, long timeId, String nodeId, String attribute, Object oldValue,
&nbsp;			Object newValue) {
<b class="nc">&nbsp;		listeners.nodeAttributeChanged(sourceId, timeId, nodeId, attribute, oldValue, newValue);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see
&nbsp;	 * org.graphstream.stream.AttributeSink#nodeAttributeRemoved(java.lang.String ,
&nbsp;	 * long, java.lang.String, java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void nodeAttributeRemoved(String sourceId, long timeId, String nodeId, String attribute) {
<b class="nc">&nbsp;		listeners.nodeAttributeRemoved(sourceId, timeId, nodeId, attribute);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#edgeAdded(java.lang.String, long,
&nbsp;	 * java.lang.String, java.lang.String, java.lang.String, boolean)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void edgeAdded(String sourceId, long timeId, String edgeId, String fromNodeId, String toNodeId,
&nbsp;			boolean directed) {
<b class="nc">&nbsp;		listeners.edgeAdded(sourceId, timeId, edgeId, fromNodeId, toNodeId, directed);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#edgeRemoved(java.lang.String, long,
&nbsp;	 * java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void edgeRemoved(String sourceId, long timeId, String edgeId) {
<b class="nc">&nbsp;		listeners.edgeRemoved(sourceId, timeId, edgeId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#graphCleared(java.lang.String, long)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void graphCleared(String sourceId, long timeId) {
<b class="nc">&nbsp;		listeners.graphCleared(sourceId, timeId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#nodeAdded(java.lang.String, long,
&nbsp;	 * java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void nodeAdded(String sourceId, long timeId, String nodeId) {
<b class="nc">&nbsp;		listeners.nodeAdded(sourceId, timeId, nodeId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#nodeRemoved(java.lang.String, long,
&nbsp;	 * java.lang.String)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void nodeRemoved(String sourceId, long timeId, String nodeId) {
<b class="nc">&nbsp;		listeners.nodeRemoved(sourceId, timeId, nodeId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.ElementSink#stepBegins(java.lang.String, long,
&nbsp;	 * double)
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void stepBegins(String sourceId, long timeId, double time) {
<b class="nc">&nbsp;		listeners.sendStepBegins(sourceId, timeId, time);</b>
<b class="nc">&nbsp;		stepBegins(time);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Sprite interface
&nbsp;
&nbsp;	protected void spriteAttribute(AttributeChangeEvent event, Element element, String attribute, Object value) {
<b class="nc">&nbsp;		String spriteId = attribute.substring(10); // Remove the &quot;ui.sprite.&quot;</b>
&nbsp;		// prefix.
<b class="nc">&nbsp;		int pos = spriteId.indexOf(&#39;.&#39;); // Look if there is something after the</b>
&nbsp;		// sprite id.
<b class="nc">&nbsp;		String attr = null;</b>
&nbsp;
<b class="nc">&nbsp;		if (pos &gt; 0) {</b>
<b class="nc">&nbsp;			attr = spriteId.substring(pos + 1); // Cut the sprite id.</b>
<b class="nc">&nbsp;			spriteId = spriteId.substring(0, pos); // Cut the sprite attribute</b>
&nbsp;			// name.
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (attr == null) {</b>
<b class="nc">&nbsp;			addOrChangeSprite(event, element, spriteId, value);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			if (event == AttributeChangeEvent.ADD) {</b>
<b class="nc">&nbsp;				GraphicSprite sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;
&nbsp;				// We add the sprite, in case of a replay, some attributes of
&nbsp;				// the sprite can be
&nbsp;				// changed before the sprite is declared.
<b class="nc">&nbsp;				if (sprite == null) {</b>
<b class="nc">&nbsp;					addOrChangeSprite(AttributeChangeEvent.ADD, element, spriteId, null);</b>
<b class="nc">&nbsp;					sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				sprite.setAttribute(attr, value);</b>
<b class="nc">&nbsp;			} else if (event == AttributeChangeEvent.CHANGE) {</b>
<b class="nc">&nbsp;				GraphicSprite sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;
<b class="nc">&nbsp;				if (sprite == null) {</b>
<b class="nc">&nbsp;					addOrChangeSprite(AttributeChangeEvent.ADD, element, spriteId, null);</b>
<b class="nc">&nbsp;					sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				sprite.setAttribute(attr, value);</b>
<b class="nc">&nbsp;			} else if (event == AttributeChangeEvent.REMOVE) {</b>
<b class="nc">&nbsp;				GraphicSprite sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;
<b class="nc">&nbsp;				if (sprite != null)</b>
<b class="nc">&nbsp;					sprite.removeAttribute(attr);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected void addOrChangeSprite(AttributeChangeEvent event, Element element, String spriteId, Object value) {
&nbsp;
<b class="nc">&nbsp;		if (event == AttributeChangeEvent.ADD || event == AttributeChangeEvent.CHANGE) {</b>
<b class="nc">&nbsp;			GraphicSprite sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;
<b class="nc">&nbsp;			if (sprite == null)</b>
<b class="nc">&nbsp;				sprite = addSprite_(spriteId);</b>
&nbsp;
<b class="nc">&nbsp;			if (element != null) {</b>
<b class="nc">&nbsp;				if (element instanceof GraphicNode)</b>
<b class="nc">&nbsp;					sprite.attachToNode((GraphicNode) element);</b>
<b class="nc">&nbsp;				else if (element instanceof GraphicEdge)</b>
<b class="nc">&nbsp;					sprite.attachToEdge((GraphicEdge) element);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (value != null &amp;&amp; (!(value instanceof Boolean)))</b>
<b class="nc">&nbsp;				positionSprite(sprite, value);</b>
<b class="nc">&nbsp;		} else if (event == AttributeChangeEvent.REMOVE) {</b>
<b class="nc">&nbsp;			if (element == null) {</b>
<b class="nc">&nbsp;				if (styleGroups.getSprite(spriteId) != null) {</b>
<b class="nc">&nbsp;					removeSprite_(spriteId);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				GraphicSprite sprite = styleGroups.getSprite(spriteId);</b>
&nbsp;
<b class="nc">&nbsp;				if (sprite != null)</b>
<b class="nc">&nbsp;					sprite.detach();</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public GraphicSprite addSprite(String id) {
<b class="nc">&nbsp;		String prefix = String.format(&quot;ui.sprite.%s&quot;, id);</b>
<b class="nc">&nbsp;		logger.info(String.format(&quot;Added sprite %s.&quot;, id));</b>
<b class="nc">&nbsp;		setAttribute(prefix, 0, 0, 0);</b>
<b class="nc">&nbsp;		GraphicSprite s = styleGroups.getSprite(id);</b>
<b class="nc">&nbsp;		assert (s != null);</b>
<b class="nc">&nbsp;		return s;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected GraphicSprite addSprite_(String id) {
<b class="nc">&nbsp;		GraphicSprite s = new GraphicSprite(id, this);</b>
<b class="nc">&nbsp;		styleGroups.addElement(s);</b>
<b class="nc">&nbsp;		graphChanged = true;</b>
&nbsp;
<b class="nc">&nbsp;		return s;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void removeSprite(String id) {
<b class="nc">&nbsp;		String prefix = String.format(&quot;ui.sprite.%s&quot;, id);</b>
<b class="nc">&nbsp;		removeAttribute(prefix);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected GraphicSprite removeSprite_(String id) {
<b class="nc">&nbsp;		GraphicSprite sprite = (GraphicSprite) styleGroups.getSprite(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (sprite != null) {</b>
<b class="nc">&nbsp;			sprite.detach();</b>
<b class="nc">&nbsp;			styleGroups.removeElement(sprite);</b>
<b class="nc">&nbsp;			sprite.removed();</b>
&nbsp;
<b class="nc">&nbsp;			graphChanged = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return sprite;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void positionSprite(GraphicSprite sprite, Object value) {
<b class="nc">&nbsp;		if (value instanceof Object[]) {</b>
<b class="nc">&nbsp;			Object[] values = (Object[]) value;</b>
&nbsp;
<b class="nc">&nbsp;			if (values.length == 4) {</b>
<b class="nc">&nbsp;				if (values[0] instanceof Number &amp;&amp; values[1] instanceof Number &amp;&amp; values[2] instanceof Number</b>
&nbsp;						&amp;&amp; values[3] instanceof Style.Units) {
<b class="nc">&nbsp;					sprite.setPosition(((Number) values[0]).doubleValue(), ((Number) values[1]).doubleValue(),</b>
<b class="nc">&nbsp;							((Number) values[2]).doubleValue(), (Style.Units) values[3]);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					logger.warning(&quot;Cannot parse values[4] for sprite position.&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;			} else if (values.length == 3) {</b>
<b class="nc">&nbsp;				if (values[0] instanceof Number &amp;&amp; values[1] instanceof Number &amp;&amp; values[2] instanceof Number) {</b>
<b class="nc">&nbsp;					sprite.setPosition(((Number) values[0]).doubleValue(), ((Number) values[1]).doubleValue(),</b>
<b class="nc">&nbsp;							((Number) values[2]).doubleValue(), Units.GU);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					logger.warning(&quot;Cannot parse values[3] for sprite position.&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;			} else if (values.length == 1) {</b>
<b class="nc">&nbsp;				if (values[0] instanceof Number) {</b>
<b class="nc">&nbsp;					sprite.setPosition(((Number) values[0]).doubleValue());</b>
&nbsp;				} else {
<b class="nc">&nbsp;					logger.warning(&quot;Sprite position percent is not a number.&quot;);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				logger.warning(String.format(&quot;Cannot transform value &#39;%s&#39; (length=%d) into a position%n&quot;,</b>
<b class="nc">&nbsp;						Arrays.toString(values), values.length));</b>
&nbsp;			}
<b class="nc">&nbsp;		} else if (value instanceof Number) {</b>
<b class="nc">&nbsp;			sprite.setPosition(((Number) value).doubleValue());</b>
<b class="nc">&nbsp;		} else if (value instanceof Value) {</b>
<b class="nc">&nbsp;			sprite.setPosition(((Value) value).value);</b>
<b class="nc">&nbsp;		} else if (value instanceof Values) {</b>
<b class="nc">&nbsp;			sprite.setPosition((Values) value);</b>
<b class="nc">&nbsp;		} else if (value == null) {</b>
<b class="nc">&nbsp;			throw new RuntimeException(&quot;What do you expect with a null value ?&quot;);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			logger.warning(String.format(&quot;Cannot place sprite with posiiton &#39;%s&#39; (instance of %s)%n&quot;, value,</b>
<b class="nc">&nbsp;					value.getClass().getName()));</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#clearAttributeSinks()
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void clearAttributeSinks() {
<b class="nc">&nbsp;		listeners.clearAttributeSinks();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * *(non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#clearElementSinks()
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void clearElementSinks() {
<b class="nc">&nbsp;		listeners.clearElementSinks();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 * 
&nbsp;	 * @see org.graphstream.stream.Source#clearSinks()
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void clearSinks() {
<b class="nc">&nbsp;		listeners.clearSinks();</b>
&nbsp;	}
&nbsp;
&nbsp;	// stubs for the new methods
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge addEdge(String id, int index1, int index2) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge addEdge(String id, int fromIndex, int toIndex, boolean directed) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge addEdge(String id, Node node1, Node node2) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge addEdge(String id, Node from, Node to, boolean directed) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge getEdge(int index) throws IndexOutOfBoundsException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Node getNode(int index) throws IndexOutOfBoundsException {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge removeEdge(int index) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge removeEdge(int fromIndex, int toIndex) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge removeEdge(Node node1, Node node2) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Edge removeEdge(Edge edge) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Node removeNode(int index) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Node removeNode(Node node) {
<b class="nc">&nbsp;		throw new RuntimeException(&quot;not implemented !&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Replay all the elements of the graph and all attributes as new events to all
&nbsp;	 * connected sinks.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Be very careful with this method, it introduces new events in the event
&nbsp;	 * stream and some sinks may therefore receive them twice !! Graph replay is
&nbsp;	 * always dangerous !
&nbsp;	 */
&nbsp;	public void replay() {
&nbsp;		// Replay all graph attributes.
&nbsp;
<b class="nc">&nbsp;		attributeKeys().forEach(key -&gt; {</b>
<b class="nc">&nbsp;			listeners.sendGraphAttributeAdded(id, key, getAttribute(key));</b>
&nbsp;		});
&nbsp;
&nbsp;		// Replay all nodes and their attributes.
&nbsp;
<b class="nc">&nbsp;		nodes().forEach(node -&gt; {</b>
<b class="nc">&nbsp;			listeners.sendNodeAdded(id, node.getId());</b>
&nbsp;
<b class="nc">&nbsp;			node.attributeKeys().forEach(key -&gt; {</b>
<b class="nc">&nbsp;				listeners.sendNodeAttributeAdded(id, node.getId(), key, node.getAttribute(key));</b>
&nbsp;			});
&nbsp;		});
&nbsp;
&nbsp;		// Replay all edges and their attributes.
&nbsp;
<b class="nc">&nbsp;		edges().forEach(edge -&gt; {</b>
<b class="nc">&nbsp;			listeners.sendEdgeAdded(id, edge.getId(), edge.getSourceNode().getId(), edge.getTargetNode().getId(),</b>
<b class="nc">&nbsp;					edge.isDirected());</b>
&nbsp;
<b class="nc">&nbsp;			edge.attributeKeys().forEach(key -&gt; {</b>
<b class="nc">&nbsp;				listeners.sendEdgeAttributeAdded(id, edge.getId(), key, edge.getAttribute(key));</b>
&nbsp;			});
&nbsp;		});
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-07-08 16:57</div>
</div>
</body>
</html>
