


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > StyleGroupSet</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.graphstream.ui.graphicGraph</a>
</div>

<h1>Coverage Summary for Class: StyleGroupSet (org.graphstream.ui.graphicGraph)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StyleGroupSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/228)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StyleGroupSet$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$EdgeSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$ElementIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$EventSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$GraphSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$NodeSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$ShadowSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$SpriteSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$ZIndex</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StyleGroupSet$ZIndex$ZIndexIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/106)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/331)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
&nbsp; * 
&nbsp; * GraphStream is a library whose purpose is to handle static or dynamic
&nbsp; * graph, create them from scratch, file or any source and display them.
&nbsp; * 
&nbsp; * This program is free software distributed under the terms of two licenses, the
&nbsp; * CeCILL-C license that fits European law, and the GNU Lesser General Public
&nbsp; * License. You can  use, modify and/ or redistribute the software under the terms
&nbsp; * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
&nbsp; * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or (at your
&nbsp; * option) any later version.
&nbsp; * 
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT ANY
&nbsp; * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
&nbsp; * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
&nbsp; * 
&nbsp; * You should have received a copy of the GNU Lesser General Public License
&nbsp; * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; * 
&nbsp; * The fact that you are presently reading this means that you have had
&nbsp; * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * @since 2009-07-05
&nbsp; * 
&nbsp; * @author Antoine Dutot &lt;antoine.dutot@graphstream-project.org&gt;
&nbsp; * @author Yoann Pign√© &lt;yoann.pigne@graphstream-project.org&gt;
&nbsp; * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
&nbsp; * @author Alex Bowen &lt;bowen.a@gmail.com&gt;
&nbsp; * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
&nbsp; */
&nbsp;package org.graphstream.ui.graphicGraph;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.graphstream.graph.Edge;
&nbsp;import org.graphstream.graph.Element;
&nbsp;import org.graphstream.graph.Graph;
&nbsp;import org.graphstream.graph.Node;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.Rule;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.Selector;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleConstants.ShadowMode;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleSheet;
&nbsp;import org.graphstream.ui.graphicGraph.stylesheet.StyleSheetListener;
&nbsp;
&nbsp;/**
&nbsp; * A set of style groups.
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * This class is in charge or storing all the style groups and to update them.
&nbsp; * Each time an element is added or removed the groups are updated. Each time
&nbsp; * the style sheet changes the groups are updated.
&nbsp; * &lt;/p&gt;
&nbsp; * 
&nbsp; * @author Antoine Dutot
&nbsp; */
&nbsp;public class StyleGroupSet implements StyleSheetListener {
&nbsp;	// Attribute
&nbsp;
&nbsp;	/**
&nbsp;	 * The style sheet.
&nbsp;	 */
&nbsp;	protected StyleSheet stylesheet;
&nbsp;
&nbsp;	/**
&nbsp;	 * All the groups indexed by their unique identifier.
&nbsp;	 */
<b class="nc">&nbsp;	protected final Map&lt;String, StyleGroup&gt; groups = new TreeMap&lt;String, StyleGroup&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Allows to retrieve the group containing a node knowing the node id.
&nbsp;	 */
<b class="nc">&nbsp;	protected final Map&lt;String, String&gt; byNodeIdGroups = new TreeMap&lt;String, String&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Allows to retrieve the group containing an edge knowing the node id.
&nbsp;	 */
<b class="nc">&nbsp;	protected final Map&lt;String, String&gt; byEdgeIdGroups = new TreeMap&lt;String, String&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Allows to retrieve the group containing a sprite knowing the node id.
&nbsp;	 */
<b class="nc">&nbsp;	protected final Map&lt;String, String&gt; bySpriteIdGroups = new TreeMap&lt;String, String&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Allows to retrieve the group containing a graph knowing the node id.
&nbsp;	 */
<b class="nc">&nbsp;	protected final Map&lt;String, String&gt; byGraphIdGroups = new TreeMap&lt;String, String&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Virtual set of nodes. This set provides fake methods to make it appear as a
&nbsp;	 * set of nodes whereas it only maps on the node style groups.
&nbsp;	 */
<b class="nc">&nbsp;	protected NodeSet nodeSet = new NodeSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Virtual set of edges. This set provides fake methods to make it appear as a
&nbsp;	 * set of edges whereas it only maps on the edge style groups.
&nbsp;	 */
<b class="nc">&nbsp;	protected EdgeSet edgeSet = new EdgeSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Virtual set of sprites. This set provides fake methods to make it appear as a
&nbsp;	 * set of sprites whereas it only maps on the sprite style groups.
&nbsp;	 */
<b class="nc">&nbsp;	protected SpriteSet spriteSet = new SpriteSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Virtual set of graphs. This set provides fake methods to make it appear as a
&nbsp;	 * set of graphs whereas it only maps on the graph style groups.
&nbsp;	 */
<b class="nc">&nbsp;	protected GraphSet graphSet = new GraphSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The set of events actually occurring.
&nbsp;	 */
<b class="nc">&nbsp;	protected EventSet eventSet = new EventSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The groups sorted by their Z index.
&nbsp;	 */
<b class="nc">&nbsp;	protected ZIndex zIndex = new ZIndex();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of groups that cast shadow.
&nbsp;	 */
<b class="nc">&nbsp;	protected ShadowSet shadow = new ShadowSet();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Remove groups if they become empty?.
&nbsp;	 */
<b class="nc">&nbsp;	protected boolean removeEmptyGroups = true;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of listeners.
&nbsp;	 */
<b class="nc">&nbsp;	protected ArrayList&lt;StyleGroupListener&gt; listeners = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	// Construction
&nbsp;
&nbsp;	/**
&nbsp;	 * New empty style group set, using the given style sheet to create style
&nbsp;	 * groups. The group set installs itself as a listener of the style sheet. So in
&nbsp;	 * order to completely stop using such a group, you must call
&nbsp;	 * {@link #release()}.
&nbsp;	 * 
&nbsp;	 * @param stylesheet
&nbsp;	 *            The style sheet to use to create groups.
&nbsp;	 */
<b class="nc">&nbsp;	public StyleGroupSet(StyleSheet stylesheet) {</b>
<b class="nc">&nbsp;		this.stylesheet = stylesheet;</b>
&nbsp;
<b class="nc">&nbsp;		stylesheet.addListener(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Access
&nbsp;
&nbsp;	/**
&nbsp;	 * Number of groups.
&nbsp;	 * 
&nbsp;	 * @return The number of groups.
&nbsp;	 */
&nbsp;	public int getGroupCount() {
<b class="nc">&nbsp;		return groups.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a group by its unique identifier. The way group identifier are
&nbsp;	 * constructed reflects their contents.
&nbsp;	 * 
&nbsp;	 * @param groupId
&nbsp;	 *            The group identifier.
&nbsp;	 * @return The corresponding group or null if not found.
&nbsp;	 */
&nbsp;	public StyleGroup getGroup(String groupId) {
<b class="nc">&nbsp;		return groups.get(groupId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the set of groups in no particular order.
&nbsp;	 * 
&nbsp;	 * @return An iterator on the group set.
&nbsp;	 */
&nbsp;	public Iterator&lt;? extends StyleGroup&gt; getGroupIterator() {
<b class="nc">&nbsp;		return groups.values().iterator();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterable set of groups elements, in no particular order.
&nbsp;	 * 
&nbsp;	 * @return An iterable on the set of groups.
&nbsp;	 */
&nbsp;	public Iterable&lt;? extends StyleGroup&gt; groups() {
<b class="nc">&nbsp;		return groups.values();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the Z index.
&nbsp;	 * 
&nbsp;	 * @return The z index iterator.
&nbsp;	 */
&nbsp;	public Iterator&lt;HashSet&lt;StyleGroup&gt;&gt; getZIterator() {
<b class="nc">&nbsp;		return zIndex.getIterator();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterable set of &quot;subsets of groups&quot; sorted by Z level. Each subset of groups
&nbsp;	 * is at the same Z level.
&nbsp;	 * 
&nbsp;	 * @return The z levels.
&nbsp;	 */
&nbsp;	public Iterable&lt;HashSet&lt;StyleGroup&gt;&gt; zIndex() {
<b class="nc">&nbsp;		return zIndex;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the style groups that cast a shadow.
&nbsp;	 * 
&nbsp;	 * @return The shadow groups iterator.
&nbsp;	 */
&nbsp;	public Iterator&lt;StyleGroup&gt; getShadowIterator() {
<b class="nc">&nbsp;		return shadow.getIterator();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterable set of groups that cast shadow.
&nbsp;	 * 
&nbsp;	 * @return All the groups that cast a shadow.
&nbsp;	 */
&nbsp;	public Iterable&lt;StyleGroup&gt; shadows() {
<b class="nc">&nbsp;		return shadow;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * True if the set contains and styles the node whose identifier is given.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The node identifier.
&nbsp;	 * @return True if the node is in this set.
&nbsp;	 */
&nbsp;	public boolean containsNode(String id) {
<b class="nc">&nbsp;		return byNodeIdGroups.containsKey(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * True if the set contains and styles the edge whose identifier is given.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The edge identifier.
&nbsp;	 * @return True if the edge is in this set.
&nbsp;	 */
&nbsp;	public boolean containsEdge(String id) {
<b class="nc">&nbsp;		return byEdgeIdGroups.containsKey(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * True if the set contains and styles the sprite whose identifier is given.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The sprite identifier.
&nbsp;	 * @return True if the sprite is in this set.
&nbsp;	 */
&nbsp;	public boolean containsSprite(String id) {
<b class="nc">&nbsp;		return bySpriteIdGroups.containsKey(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * True if the set contains and styles the graph whose identifier is given.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The graph identifier.
&nbsp;	 * @return True if the graph is in this set.
&nbsp;	 */
&nbsp;	public boolean containsGraph(String id) {
<b class="nc">&nbsp;		return byGraphIdGroups.containsKey(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get an element.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The element id.
&nbsp;	 * @param elt2grp
&nbsp;	 *            The kind of element.
&nbsp;	 * @return The element or null if not found.
&nbsp;	 */
&nbsp;	protected Element getElement(String id, Map&lt;String, String&gt; elt2grp) {
<b class="nc">&nbsp;		String gid = elt2grp.get(id);</b>
&nbsp;
<b class="nc">&nbsp;		if (gid != null) {</b>
<b class="nc">&nbsp;			StyleGroup group = groups.get(gid);</b>
<b class="nc">&nbsp;			return group.getElement(id);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get a node element knowing its identifier.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The node identifier.
&nbsp;	 * @return The node if it is in this set, else null.
&nbsp;	 */
&nbsp;	public Node getNode(String id) {
<b class="nc">&nbsp;		return (Node) getElement(id, byNodeIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get an edge element knowing its identifier.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The edge identifier.
&nbsp;	 * @return The edge if it is in this set, else null.
&nbsp;	 */
&nbsp;	public Edge getEdge(String id) {
<b class="nc">&nbsp;		return (Edge) getElement(id, byEdgeIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get a sprite element knowing its identifier.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The sprite identifier.
&nbsp;	 * @return The sprite if it is in this set, else null.
&nbsp;	 */
&nbsp;	public GraphicSprite getSprite(String id) {
<b class="nc">&nbsp;		return (GraphicSprite) getElement(id, bySpriteIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get a graph element knowing its identifier.
&nbsp;	 * 
&nbsp;	 * @param id
&nbsp;	 *            The graph identifier.
&nbsp;	 * @return The graph if it is in this set, else null.
&nbsp;	 */
&nbsp;	public Graph getGraph(String id) {
<b class="nc">&nbsp;		return (Graph) getElement(id, byGraphIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of nodes referenced.
&nbsp;	 * 
&nbsp;	 * @return The node count.
&nbsp;	 */
&nbsp;	public int getNodeCount() {
<b class="nc">&nbsp;		return byNodeIdGroups.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of edges referenced.
&nbsp;	 * 
&nbsp;	 * @return The edge count.
&nbsp;	 */
&nbsp;	public int getEdgeCount() {
<b class="nc">&nbsp;		return byEdgeIdGroups.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of sprites referenced.
&nbsp;	 * 
&nbsp;	 * @return The sprite count.
&nbsp;	 */
&nbsp;	public int getSpriteCount() {
<b class="nc">&nbsp;		return bySpriteIdGroups.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the set of nodes.
&nbsp;	 * 
&nbsp;	 * @return An iterator on all node elements contained in style groups.
&nbsp;	 */
&nbsp;	public Iterator&lt;? extends Node&gt; getNodeIterator() {
<b class="nc">&nbsp;		return new ElementIterator&lt;Node&gt;(byNodeIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the set of graphs.
&nbsp;	 * 
&nbsp;	 * @return An iterator on all graph elements contained in style groups.
&nbsp;	 */
&nbsp;	public Iterator&lt;? extends Graph&gt; getGraphIterator() {
<b class="nc">&nbsp;		return new ElementIterator&lt;Graph&gt;(byGraphIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Stream&lt;Node&gt; nodes() {
<b class="nc">&nbsp;		return byNodeIdGroups.entrySet().stream().map(entry -&gt; {</b>
<b class="nc">&nbsp;			return (Node) groups.get(entry.getValue()).getElement(entry.getKey());</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	public Stream&lt;Edge&gt; edges() {
<b class="nc">&nbsp;		return byEdgeIdGroups.entrySet().stream().map(entry -&gt; {</b>
<b class="nc">&nbsp;			return (Edge) groups.get(entry.getValue()).getElement(entry.getKey());</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	public Stream&lt;GraphicSprite&gt; sprites() {
<b class="nc">&nbsp;		return bySpriteIdGroups.entrySet().stream().map(entry -&gt; {</b>
<b class="nc">&nbsp;			return (GraphicSprite) groups.get(entry.getValue()).getElement(entry.getKey());</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterable set of graphs.
&nbsp;	 * 
&nbsp;	 * @return The set of all graphs.
&nbsp;	 */
&nbsp;	public Iterable&lt;? extends Graph&gt; graphs() {
<b class="nc">&nbsp;		return graphSet;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the set of edges.
&nbsp;	 * 
&nbsp;	 * @return An iterator on all edge elements contained in style groups.
&nbsp;	 */
&nbsp;	public Iterator&lt;? extends Edge&gt; getEdgeIterator() {
<b class="nc">&nbsp;		return new ElementIterator&lt;Edge&gt;(byEdgeIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator on the set of sprite.
&nbsp;	 * 
&nbsp;	 * @return An iterator on all sprite elements contained in style groups.
&nbsp;	 */
&nbsp;	public Iterator&lt;? extends GraphicSprite&gt; getSpriteIterator() {
<b class="nc">&nbsp;		return new ElementIterator&lt;GraphicSprite&gt;(bySpriteIdGroups);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieve the group identifier of an element knowing the element identifier.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to search for.
&nbsp;	 * @return Identifier of the group containing the element.
&nbsp;	 */
&nbsp;	public String getElementGroup(Element element) {
<b class="nc">&nbsp;		if (element instanceof Node) {</b>
<b class="nc">&nbsp;			return byNodeIdGroups.get(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof Edge) {</b>
<b class="nc">&nbsp;			return byEdgeIdGroups.get(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof GraphicSprite) {</b>
<b class="nc">&nbsp;			return bySpriteIdGroups.get(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof Graph) {</b>
<b class="nc">&nbsp;			return byGraphIdGroups.get(element.getId());</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new RuntimeException(&quot;What ?&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the style of an element.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to search for.
&nbsp;	 * @return The style group of the element (which is also a style).
&nbsp;	 */
&nbsp;	public StyleGroup getStyleForElement(Element element) {
<b class="nc">&nbsp;		String gid = getElementGroup(element);</b>
&nbsp;
<b class="nc">&nbsp;		return groups.get(gid);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the style of a given node.
&nbsp;	 * 
&nbsp;	 * @param node
&nbsp;	 *            The node to search for.
&nbsp;	 * @return The node style.
&nbsp;	 */
&nbsp;	public StyleGroup getStyleFor(Node node) {
<b class="nc">&nbsp;		String gid = byNodeIdGroups.get(node.getId());</b>
<b class="nc">&nbsp;		return groups.get(gid);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the style of a given edge.
&nbsp;	 * 
&nbsp;	 * @param edge
&nbsp;	 *            The edge to search for.
&nbsp;	 * @return The edge style.
&nbsp;	 */
&nbsp;	public StyleGroup getStyleFor(Edge edge) {
<b class="nc">&nbsp;		String gid = byEdgeIdGroups.get(edge.getId());</b>
<b class="nc">&nbsp;		return groups.get(gid);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the style of a given sprite.
&nbsp;	 * 
&nbsp;	 * @param sprite
&nbsp;	 *            The node to search for.
&nbsp;	 * @return The sprite style.
&nbsp;	 */
&nbsp;	public StyleGroup getStyleFor(GraphicSprite sprite) {
<b class="nc">&nbsp;		String gid = bySpriteIdGroups.get(sprite.getId());</b>
<b class="nc">&nbsp;		return groups.get(gid);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the style of a given graph.
&nbsp;	 * 
&nbsp;	 * @param graph
&nbsp;	 *            The node to search for.
&nbsp;	 * @return The graph style.
&nbsp;	 */
&nbsp;	public StyleGroup getStyleFor(Graph graph) {
<b class="nc">&nbsp;		String gid = byGraphIdGroups.get(graph.getId());</b>
<b class="nc">&nbsp;		return groups.get(gid);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * True if groups are removed when becoming empty. This setting allows to keep
&nbsp;	 * empty group when the set of elements is quite dynamic. This allows to avoid
&nbsp;	 * recreting groups when an element appears and disappears regularly.
&nbsp;	 * 
&nbsp;	 * @return True if the groups are removed when empty.
&nbsp;	 */
&nbsp;	public boolean areEmptyGroupRemoved() {
<b class="nc">&nbsp;		return removeEmptyGroups;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The Z index object.
&nbsp;	 * 
&nbsp;	 * @return The Z index.
&nbsp;	 */
&nbsp;	public ZIndex getZIndex() {
<b class="nc">&nbsp;		return zIndex;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The set of style groups that cast a shadow.
&nbsp;	 * 
&nbsp;	 * @return The set of shadowed style groups.
&nbsp;	 */
&nbsp;	public ShadowSet getShadowSet() {
<b class="nc">&nbsp;		return shadow;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Command
&nbsp;
&nbsp;	/**
&nbsp;	 * Release any dependency to the style sheet.
&nbsp;	 */
&nbsp;	public void release() {
<b class="nc">&nbsp;		stylesheet.removeListener(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Empties this style group set. The style sheet is listener is not removed, use
&nbsp;	 * {@link #release()} to do that.
&nbsp;	 */
&nbsp;	public void clear() {
<b class="nc">&nbsp;		byEdgeIdGroups.clear();</b>
<b class="nc">&nbsp;		byNodeIdGroups.clear();</b>
<b class="nc">&nbsp;		bySpriteIdGroups.clear();</b>
<b class="nc">&nbsp;		byGraphIdGroups.clear();</b>
<b class="nc">&nbsp;		groups.clear();</b>
<b class="nc">&nbsp;		zIndex.clear();</b>
<b class="nc">&nbsp;		shadow.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Remove or keep groups that becomes empty, if true the groups are removed. If
&nbsp;	 * this setting was set to false, and is now true, the group set is purged of
&nbsp;	 * the empty groups.
&nbsp;	 * 
&nbsp;	 * @param on
&nbsp;	 *            If true the groups will be removed.
&nbsp;	 */
&nbsp;	public void setRemoveEmptyGroups(boolean on) {
<b class="nc">&nbsp;		if (removeEmptyGroups == false &amp;&amp; on == true) {</b>
<b class="nc">&nbsp;			Iterator&lt;? extends StyleGroup&gt; i = groups.values().iterator();</b>
&nbsp;
<b class="nc">&nbsp;			while (i.hasNext()) {</b>
<b class="nc">&nbsp;				StyleGroup g = i.next();</b>
&nbsp;
<b class="nc">&nbsp;				if (g.isEmpty())</b>
<b class="nc">&nbsp;					i.remove();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		removeEmptyGroups = on;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected StyleGroup addGroup(String id, ArrayList&lt;Rule&gt; rules, Element firstElement) {
<b class="nc">&nbsp;		StyleGroup group = new StyleGroup(id, rules, firstElement, eventSet);</b>
&nbsp;
<b class="nc">&nbsp;		groups.put(id, group);</b>
<b class="nc">&nbsp;		zIndex.groupAdded(group);</b>
<b class="nc">&nbsp;		shadow.groupAdded(group);</b>
&nbsp;
<b class="nc">&nbsp;		return group;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void removeGroup(StyleGroup group) {
<b class="nc">&nbsp;		zIndex.groupRemoved(group);</b>
<b class="nc">&nbsp;		shadow.groupRemoved(group);</b>
<b class="nc">&nbsp;		groups.remove(group.getId());</b>
<b class="nc">&nbsp;		group.release();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add an element and bind it to its style group. The group is created if
&nbsp;	 * needed.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to add.
&nbsp;	 * @return The style group where the element was added.
&nbsp;	 */
&nbsp;	public StyleGroup addElement(Element element) {
<b class="nc">&nbsp;		StyleGroup group = addElement_(element);</b>
&nbsp;
<b class="nc">&nbsp;		for (StyleGroupListener listener : listeners)</b>
<b class="nc">&nbsp;			listener.elementStyleChanged(element, null, group);</b>
&nbsp;
<b class="nc">&nbsp;		return group;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected StyleGroup addElement_(Element element) {
<b class="nc">&nbsp;		ArrayList&lt;Rule&gt; rules = stylesheet.getRulesFor(element);</b>
<b class="nc">&nbsp;		String gid = stylesheet.getStyleGroupIdFor(element, rules);</b>
<b class="nc">&nbsp;		StyleGroup group = groups.get(gid);</b>
&nbsp;
<b class="nc">&nbsp;		if (group == null)</b>
<b class="nc">&nbsp;			group = addGroup(gid, rules, element);</b>
&nbsp;		else
<b class="nc">&nbsp;			group.addElement(element);</b>
&nbsp;
<b class="nc">&nbsp;		addElementToReverseSearch(element, gid);</b>
&nbsp;
<b class="nc">&nbsp;		return group;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Remove an element from the group set. If the group becomes empty after the
&nbsp;	 * element removal, depending on the setting of {@link #areEmptyGroupRemoved()},
&nbsp;	 * the group is deleted or kept. Keeping groups allows to handle faster elements
&nbsp;	 * that constantly appear and disappear.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to remove.
&nbsp;	 */
&nbsp;	public void removeElement(Element element) {
<b class="nc">&nbsp;		String gid = getElementGroup(element);</b>
<b class="nc">&nbsp;		if (null == gid) {</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		StyleGroup group = groups.get(gid);</b>
&nbsp;
<b class="nc">&nbsp;		if (group != null) {</b>
<b class="nc">&nbsp;			group.removeElement(element);</b>
<b class="nc">&nbsp;			removeElementFromReverseSearch(element);</b>
&nbsp;
<b class="nc">&nbsp;			if (removeEmptyGroups &amp;&amp; group.isEmpty())</b>
<b class="nc">&nbsp;				removeGroup(group);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Check if an element need to change from a style group to another.
&nbsp;	 * 
&nbsp;	 * &lt;p&gt;
&nbsp;	 * When an element can have potentially changed style due to some of its
&nbsp;	 * attributes (ui.class for example), instead of removing it then reading it,
&nbsp;	 * use this method to move the element from its current style group to a
&nbsp;	 * potentially different style group.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * 
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Explanation of this method : checking the style of an element may be done by
&nbsp;	 * removing it ({@link #removeElement(Element)}) and then re-adding it (
&nbsp;	 * {@link #addElement(Element)}). This must be done by the element since it
&nbsp;	 * knows when to check this. However you cannot only remove and add, since the
&nbsp;	 * style group inside which the element is can have events occurring on it, and
&nbsp;	 * these events must be passed from its old style to its new style. This method
&nbsp;	 * does all this information passing.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to move.
&nbsp;	 */
&nbsp;	public void checkElementStyleGroup(Element element) {
<b class="nc">&nbsp;		StyleGroup oldGroup = getGroup(getElementGroup(element));</b>
&nbsp;
&nbsp;		// Get the old element &quot;dynamic&quot; status.
&nbsp;
<b class="nc">&nbsp;		boolean isDyn = false;</b>
&nbsp;
&nbsp;		// Get the old event set for the given element.
&nbsp;
<b class="nc">&nbsp;		StyleGroup.ElementEvents events = null;</b>
&nbsp;
<b class="nc">&nbsp;		if (oldGroup != null) {</b>
<b class="nc">&nbsp;			isDyn = oldGroup.isElementDynamic(element);</b>
<b class="nc">&nbsp;			events = oldGroup.getEventsFor(element);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Remove the element from its old style and add it to insert it in the
&nbsp;		// correct style.
&nbsp;
<b class="nc">&nbsp;		removeElement(element);</b>
<b class="nc">&nbsp;		addElement_(element);</b>
&nbsp;
&nbsp;		// Eventually push the events on the new style group.
&nbsp;
<b class="nc">&nbsp;		StyleGroup newGroup = getGroup(getElementGroup(element));</b>
&nbsp;
<b class="nc">&nbsp;		if (newGroup != null &amp;&amp; events != null) {</b>
<b class="nc">&nbsp;			for (String event : events.events)</b>
<b class="nc">&nbsp;				pushEventFor(element, event);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		for (StyleGroupListener listener : listeners)</b>
<b class="nc">&nbsp;			listener.elementStyleChanged(element, oldGroup, newGroup);</b>
&nbsp;
&nbsp;		// Eventually set the element as dynamic, if it was.
&nbsp;
<b class="nc">&nbsp;		if (newGroup != null &amp;&amp; isDyn)</b>
<b class="nc">&nbsp;			newGroup.pushElementAsDynamic(element);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void addElementToReverseSearch(Element element, String groupId) {
<b class="nc">&nbsp;		if (element instanceof Node) {</b>
<b class="nc">&nbsp;			byNodeIdGroups.put(element.getId(), groupId);</b>
<b class="nc">&nbsp;		} else if (element instanceof Edge) {</b>
<b class="nc">&nbsp;			byEdgeIdGroups.put(element.getId(), groupId);</b>
<b class="nc">&nbsp;		} else if (element instanceof GraphicSprite) {</b>
<b class="nc">&nbsp;			bySpriteIdGroups.put(element.getId(), groupId);</b>
<b class="nc">&nbsp;		} else if (element instanceof Graph) {</b>
<b class="nc">&nbsp;			byGraphIdGroups.put(element.getId(), groupId);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new RuntimeException(&quot;What ?&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected void removeElementFromReverseSearch(Element element) {
<b class="nc">&nbsp;		if (element instanceof Node) {</b>
<b class="nc">&nbsp;			byNodeIdGroups.remove(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof Edge) {</b>
<b class="nc">&nbsp;			byEdgeIdGroups.remove(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof GraphicSprite) {</b>
<b class="nc">&nbsp;			bySpriteIdGroups.remove(element.getId());</b>
<b class="nc">&nbsp;		} else if (element instanceof Graph) {</b>
<b class="nc">&nbsp;			byGraphIdGroups.remove(element.getId());</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new RuntimeException(&quot;What ?&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Push a global event on the event stack. Events trigger the replacement of a
&nbsp;	 * style by an alternative style (or meta-class) when possible. If an event is
&nbsp;	 * on the event stack, each time a style has an alternative corresponding to the
&nbsp;	 * event, the alternative is used instead of the style.
&nbsp;	 * 
&nbsp;	 * @param event
&nbsp;	 *            The event to push.
&nbsp;	 */
&nbsp;	public void pushEvent(String event) {
<b class="nc">&nbsp;		eventSet.pushEvent(event);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Push an event specifically for a given element. This is normally done
&nbsp;	 * automatically by the graphic element.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element considered.
&nbsp;	 * @param event
&nbsp;	 *            The event to push.
&nbsp;	 */
&nbsp;	public void pushEventFor(Element element, String event) {
<b class="nc">&nbsp;		StyleGroup group = getGroup(getElementGroup(element));</b>
&nbsp;
<b class="nc">&nbsp;		if (group != null)</b>
<b class="nc">&nbsp;			group.pushEventFor(element, event);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Pop a global event from the event set.
&nbsp;	 * 
&nbsp;	 * @param event
&nbsp;	 *            The event to remove.
&nbsp;	 */
&nbsp;	public void popEvent(String event) {
<b class="nc">&nbsp;		eventSet.popEvent(event);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Pop an event specifically for a given element. This is normally done
&nbsp;	 * automatically by the graphic element.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element considered.
&nbsp;	 * @param event
&nbsp;	 *            The event to pop.
&nbsp;	 */
&nbsp;	public void popEventFor(Element element, String event) {
<b class="nc">&nbsp;		StyleGroup group = getGroup(getElementGroup(element));</b>
&nbsp;
<b class="nc">&nbsp;		if (group != null)</b>
<b class="nc">&nbsp;			group.popEventFor(element, event);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Specify the given element has dynamic style attribute values. This is
&nbsp;	 * normally done automatically by the graphic element.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to add to the dynamic subset.
&nbsp;	 */
&nbsp;	public void pushElementAsDynamic(Element element) {
<b class="nc">&nbsp;		StyleGroup group = getGroup(getElementGroup(element));</b>
&nbsp;
<b class="nc">&nbsp;		if (group != null)</b>
<b class="nc">&nbsp;			group.pushElementAsDynamic(element);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Remove the given element from the subset of elements having dynamic style
&nbsp;	 * attribute values. This is normally done automatically by the graphic element.
&nbsp;	 * 
&nbsp;	 * @param element
&nbsp;	 *            The element to remove from the dynamic subset.
&nbsp;	 */
&nbsp;	public void popElementAsDynamic(Element element) {
<b class="nc">&nbsp;		StyleGroup group = getGroup(getElementGroup(element));</b>
&nbsp;
<b class="nc">&nbsp;		if (group != null)</b>
<b class="nc">&nbsp;			group.popElementAsDynamic(element);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add a listener for element style changes.
&nbsp;	 * 
&nbsp;	 * @param listener
&nbsp;	 *            The listener to add.
&nbsp;	 */
&nbsp;	public void addListener(StyleGroupListener listener) {
<b class="nc">&nbsp;		listeners.add(listener);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Remove a style change listener.
&nbsp;	 * 
&nbsp;	 * @param listener
&nbsp;	 *            The listener to remove.
&nbsp;	 */
&nbsp;	public void removeListener(StyleGroupListener listener) {
<b class="nc">&nbsp;		int index = listeners.lastIndexOf(listener);</b>
&nbsp;
<b class="nc">&nbsp;		if (index &gt;= 0) {</b>
<b class="nc">&nbsp;			listeners.remove(index);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// Listener -- What to do when a change occurs in the style sheet.
&nbsp;
&nbsp;	public void styleAdded(Rule oldRule, Rule newRule) {
&nbsp;		// When a style change, we need to update groups.
&nbsp;		// Several cases :
&nbsp;		// 1. The style already exists
&nbsp;		// * Nothing to do in fact. All the elements are still in place.
&nbsp;		// No style rule (selectors) changed, and therefore we do not have
&nbsp;		// to change the groups since they are built using the selectors.
&nbsp;		// 2. The style is new
&nbsp;		// * we need to check all the groups concerning this kind of element (we
&nbsp;		// can
&nbsp;		// restrict our search to these groups, since other will not be
&nbsp;		// impacted),
&nbsp;		// and check all elements of these groups.
&nbsp;
<b class="nc">&nbsp;		if (oldRule == null)</b>
<b class="nc">&nbsp;			checkForNewStyle(newRule); // no need to check Z and shadow, done</b>
&nbsp;										// when adding/changing group.
&nbsp;		else
<b class="nc">&nbsp;			checkZIndexAndShadow(oldRule, newRule);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void styleSheetCleared() {
<b class="nc">&nbsp;		ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		for (Element element : graphs())</b>
<b class="nc">&nbsp;			elements.add(element);</b>
&nbsp;
<b class="nc">&nbsp;		nodes().forEach(elements::add);</b>
<b class="nc">&nbsp;		edges().forEach(elements::add);</b>
<b class="nc">&nbsp;		sprites().forEach(elements::add);</b>
&nbsp;
<b class="nc">&nbsp;		clear();</b>
&nbsp;
<b class="nc">&nbsp;		elements.forEach(this::removeElement);</b>
<b class="nc">&nbsp;		elements.forEach(this::addElement);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Check each group that may have changed, for example to rebuild the Z index
&nbsp;	 * and the shadow set.
&nbsp;	 * 
&nbsp;	 * @param oldRule
&nbsp;	 *            The old rule that changed.
&nbsp;	 * @param newRule
&nbsp;	 *            The new rule that participated in the change.
&nbsp;	 */
&nbsp;	protected void checkZIndexAndShadow(Rule oldRule, Rule newRule) {
<b class="nc">&nbsp;		if (oldRule != null) {</b>
<b class="nc">&nbsp;			if (oldRule.selector.getId() != null || oldRule.selector.getClazz() != null) {</b>
&nbsp;				// We may accelerate things a bit when a class or id style is
&nbsp;				// modified,
&nbsp;				// since only the groups listed in the style are concerned (we
&nbsp;				// are at the
&nbsp;				// bottom of the inheritance tree).
<b class="nc">&nbsp;				if (oldRule.getGroups() != null)</b>
<b class="nc">&nbsp;					for (String s : oldRule.getGroups()) {</b>
<b class="nc">&nbsp;						StyleGroup group = groups.get(s);</b>
<b class="nc">&nbsp;						if (group != null) {</b>
<b class="nc">&nbsp;							zIndex.groupChanged(group);</b>
<b class="nc">&nbsp;							shadow.groupChanged(group);</b>
&nbsp;						}
<b class="nc">&nbsp;					}</b>
&nbsp;			} else {
&nbsp;				// For kind styles &quot;NODE&quot;, &quot;EDGE&quot;, &quot;GRAPH&quot;, &quot;SPRITE&quot;, we must
&nbsp;				// reset
&nbsp;				// the whole Z and shadows for the kind, since several styles
&nbsp;				// may
&nbsp;				// have changed.
&nbsp;
<b class="nc">&nbsp;				Selector.Type type = oldRule.selector.type;</b>
&nbsp;
<b class="nc">&nbsp;				for (StyleGroup group : groups.values()) {</b>
<b class="nc">&nbsp;					if (group.getType() == type) {</b>
<b class="nc">&nbsp;						zIndex.groupChanged(group);</b>
<b class="nc">&nbsp;						shadow.groupChanged(group);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * We try to avoid at most to affect anew styles to elements and to recreate
&nbsp;	 * groups, which is time consuming.
&nbsp;	 * 
&nbsp;	 * Two cases :
&nbsp;	 * &lt;ol&gt;
&nbsp;	 * &lt;li&gt;The style is an specific (id) style. In this case a new group may be
&nbsp;	 * added.
&nbsp;	 * &lt;ul&gt;
&nbsp;	 * &lt;li&gt;check an element matches the style and in this case create the group by
&nbsp;	 * adding the element.&lt;/li&gt;
&nbsp;	 * &lt;li&gt;else do nothing.&lt;/li&gt;
&nbsp;	 * &lt;/ul&gt;
&nbsp;	 * &lt;/li&gt;
&nbsp;	 * &lt;li&gt;The style is a kind or class style.
&nbsp;	 * &lt;ul&gt;
&nbsp;	 * &lt;li&gt;check all the groups in the kind of the style (graph, node, edge, sprite)
&nbsp;	 * and only in this kind (since other will never be affected).&lt;/li&gt;
&nbsp;	 * &lt;li&gt;remove all groups of this kind.&lt;/li&gt;
&nbsp;	 * &lt;li&gt;add all elements of this kind anew to recreate the group.&lt;/li&gt;
&nbsp;	 * &lt;/ul&gt;
&nbsp;	 * &lt;/li&gt;
&nbsp;	 * &lt;/ol&gt;
&nbsp;	 */
&nbsp;	protected void checkForNewStyle(Rule newRule) {
<b class="nc">&nbsp;		switch (newRule.selector.type) {</b>
&nbsp;		case GRAPH:
<b class="nc">&nbsp;			if (newRule.selector.getId() != null)</b>
<b class="nc">&nbsp;				checkForNewIdStyle(newRule, byGraphIdGroups);</b>
&nbsp;			else
<b class="nc">&nbsp;				checkForNewStyle(newRule, byGraphIdGroups);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case NODE:
<b class="nc">&nbsp;			if (newRule.selector.getId() != null)</b>
<b class="nc">&nbsp;				checkForNewIdStyle(newRule, byNodeIdGroups);</b>
&nbsp;			else
<b class="nc">&nbsp;				checkForNewStyle(newRule, byNodeIdGroups);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case EDGE:
<b class="nc">&nbsp;			if (newRule.selector.getId() != null)</b>
<b class="nc">&nbsp;				checkForNewIdStyle(newRule, byEdgeIdGroups);</b>
&nbsp;			else
<b class="nc">&nbsp;				checkForNewStyle(newRule, byEdgeIdGroups);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case SPRITE:
<b class="nc">&nbsp;			if (newRule.selector.getId() != null)</b>
<b class="nc">&nbsp;				checkForNewIdStyle(newRule, bySpriteIdGroups);</b>
&nbsp;			else
<b class="nc">&nbsp;				checkForNewStyle(newRule, bySpriteIdGroups);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case ANY:
&nbsp;		default:
<b class="nc">&nbsp;			throw new RuntimeException(&quot;What ?&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Check for a new specific style (applies only to one element).
&nbsp;	 * 
&nbsp;	 * @param newRule
&nbsp;	 *            The new style rule.
&nbsp;	 * @param elt2grp
&nbsp;	 *            The name space.
&nbsp;	 */
&nbsp;	protected void checkForNewIdStyle(Rule newRule, Map&lt;String, String&gt; elt2grp) {
&nbsp;		// There is only one element that matches the identifier.
&nbsp;
<b class="nc">&nbsp;		Element element = getElement(newRule.selector.getId(), elt2grp);</b>
&nbsp;
<b class="nc">&nbsp;		if (element != null) {</b>
<b class="nc">&nbsp;			checkElementStyleGroup(element);</b>
&nbsp;			// removeElement( element ); // Remove the element from its old
&nbsp;			// group. Potentially delete a group.
&nbsp;			// addElement( element ); // Add the element to its new own group
&nbsp;			// (since this is an ID style).
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Check for a new kind or class style in a given name space (node, edge,
&nbsp;	 * sprite, graph).
&nbsp;	 * 
&nbsp;	 * @param newRule
&nbsp;	 *            The new style rule.
&nbsp;	 * @param elt2grp
&nbsp;	 *            The name space.
&nbsp;	 */
&nbsp;	protected void checkForNewStyle(Rule newRule, Map&lt;String, String&gt; elt2grp) {
<b class="nc">&nbsp;		elt2grp.keySet().stream().map(eltId -&gt; getElement(eltId, elt2grp)).collect(Collectors.toList())</b>
<b class="nc">&nbsp;				.forEach(this::checkElementStyleGroup);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Utility
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		StringBuilder builder = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;		builder.append(String.format(&quot;Style groups (%d) :%n&quot;, groups.size()));</b>
&nbsp;
<b class="nc">&nbsp;		for (StyleGroup group : groups.values()) {</b>
<b class="nc">&nbsp;			builder.append(group.toString(1));</b>
<b class="nc">&nbsp;			builder.append(String.format(&quot;%n&quot;));</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		return builder.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Inner classes
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of events (meta-classes) actually active.
&nbsp;	 * 
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The event set contains the set of events actually occurring. This is used to
&nbsp;	 * select alternate styles. The events actually occurring are in precedence
&nbsp;	 * order. The last one is the most important.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * 
&nbsp;	 * @author Antoine Dutot
&nbsp;	 */
<b class="nc">&nbsp;	public class EventSet {</b>
<b class="nc">&nbsp;		public ArrayList&lt;String&gt; eventSet = new ArrayList&lt;String&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		public String events[] = new String[0];</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Add an event to the set.
&nbsp;		 * 
&nbsp;		 * @param event
&nbsp;		 *            The event to add.
&nbsp;		 */
&nbsp;		public void pushEvent(String event) {
<b class="nc">&nbsp;			eventSet.add(event);</b>
<b class="nc">&nbsp;			events = eventSet.toArray(events);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Remove an event from the set.
&nbsp;		 * 
&nbsp;		 * @param event
&nbsp;		 *            The event to remove.
&nbsp;		 */
&nbsp;		public void popEvent(String event) {
<b class="nc">&nbsp;			int index = eventSet.lastIndexOf(event);</b>
&nbsp;
<b class="nc">&nbsp;			if (index &gt;= 0)</b>
<b class="nc">&nbsp;				eventSet.remove(index);</b>
&nbsp;
<b class="nc">&nbsp;			events = eventSet.toArray(events);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * The set of events in order, the most important at the end.
&nbsp;		 * 
&nbsp;		 * @return The event set.
&nbsp;		 */
&nbsp;		public String[] getEvents() {
<b class="nc">&nbsp;			return events;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * All the style groups sorted by their Z index.
&nbsp;	 * 
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This structure is maintained by each time a group is added or removed, or
&nbsp;	 * when the style of a group changed.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * 
&nbsp;	 * @author Antoine Dutot
&nbsp;	 */
&nbsp;	public class ZIndex implements Iterable&lt;HashSet&lt;StyleGroup&gt;&gt; {
&nbsp;		/**
&nbsp;		 * Ordered set of groups.
&nbsp;		 */
<b class="nc">&nbsp;		public ArrayList&lt;HashSet&lt;StyleGroup&gt;&gt; zIndex = new ArrayList&lt;HashSet&lt;StyleGroup&gt;&gt;();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Knowing a group, tell if its Z index.
&nbsp;		 */
<b class="nc">&nbsp;		public HashMap&lt;String, Integer&gt; reverseZIndex = new HashMap&lt;String, Integer&gt;();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * New empty Z index.
&nbsp;		 */
<b class="nc">&nbsp;		public ZIndex() {</b>
<b class="nc">&nbsp;			initZIndex();</b>
&nbsp;		}
&nbsp;
&nbsp;		protected void initZIndex() {
<b class="nc">&nbsp;			zIndex.ensureCapacity(256);</b>
&nbsp;
<b class="nc">&nbsp;			for (int i = 0; i &lt; 256; i++)</b>
<b class="nc">&nbsp;				zIndex.add(null);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Iterator on the set of Z index cells. Each item is a set of style groups that
&nbsp;		 * pertain to the same Z index.
&nbsp;		 * 
&nbsp;		 * @return Iterator on the Z index.
&nbsp;		 */
&nbsp;		protected Iterator&lt;HashSet&lt;StyleGroup&gt;&gt; getIterator() {
<b class="nc">&nbsp;			return new ZIndexIterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Iterator&lt;HashSet&lt;StyleGroup&gt;&gt; iterator() {
<b class="nc">&nbsp;			return getIterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A new group appeared, put it in the z index.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group to add.
&nbsp;		 */
&nbsp;		protected void groupAdded(StyleGroup group) {
<b class="nc">&nbsp;			int z = convertZ(group.getZIndex());</b>
&nbsp;
<b class="nc">&nbsp;			if (zIndex.get(z) == null)</b>
<b class="nc">&nbsp;				zIndex.set(z, new HashSet&lt;StyleGroup&gt;());</b>
&nbsp;
<b class="nc">&nbsp;			zIndex.get(z).add(group);</b>
<b class="nc">&nbsp;			reverseZIndex.put(group.getId(), z);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A group eventually changed, check its location.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group to check.
&nbsp;		 */
&nbsp;		protected void groupChanged(StyleGroup group) {
<b class="nc">&nbsp;			int oldZ = reverseZIndex.get(group.getId());</b>
<b class="nc">&nbsp;			int newZ = convertZ(group.getZIndex());</b>
&nbsp;
<b class="nc">&nbsp;			if (oldZ != newZ) {</b>
<b class="nc">&nbsp;				HashSet&lt;StyleGroup&gt; map = zIndex.get(oldZ);</b>
&nbsp;
<b class="nc">&nbsp;				if (map != null) {</b>
<b class="nc">&nbsp;					map.remove(group);</b>
<b class="nc">&nbsp;					reverseZIndex.remove(group.getId());</b>
&nbsp;
<b class="nc">&nbsp;					if (map.isEmpty())</b>
<b class="nc">&nbsp;						zIndex.set(oldZ, null);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				groupAdded(group);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A group was removed, remove it from the Z index.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group to remove.
&nbsp;		 */
&nbsp;		protected void groupRemoved(StyleGroup group) {
<b class="nc">&nbsp;			int z = convertZ(group.getZIndex());</b>
&nbsp;
<b class="nc">&nbsp;			HashSet&lt;StyleGroup&gt; map = zIndex.get(z);</b>
&nbsp;
<b class="nc">&nbsp;			if (map != null) {</b>
<b class="nc">&nbsp;				map.remove(group);</b>
<b class="nc">&nbsp;				reverseZIndex.remove(group.getId());</b>
&nbsp;
<b class="nc">&nbsp;				if (map.isEmpty())</b>
<b class="nc">&nbsp;					zIndex.set(z, null);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw new RuntimeException(&quot;Inconsistency in Z-index&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		public void clear() {
<b class="nc">&nbsp;			zIndex.clear();</b>
<b class="nc">&nbsp;			reverseZIndex.clear();</b>
<b class="nc">&nbsp;			initZIndex();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Convert a [-127,127] value into a [0,255] value and check bounds.
&nbsp;		 * 
&nbsp;		 * @param z
&nbsp;		 *            The Z value to convert.
&nbsp;		 * @return The Z value converted and bounded to [0,255].
&nbsp;		 */
&nbsp;		protected int convertZ(int z) {
<b class="nc">&nbsp;			z += 127;</b>
&nbsp;
<b class="nc">&nbsp;			if (z &lt; 0)</b>
<b class="nc">&nbsp;				z = 0;</b>
<b class="nc">&nbsp;			else if (z &gt; 255)</b>
<b class="nc">&nbsp;				z = 255;</b>
&nbsp;
<b class="nc">&nbsp;			return z;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			StringBuilder sb = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;			sb.append(String.format(&quot;Z index :%n&quot;));</b>
&nbsp;
<b class="nc">&nbsp;			for (int i = 0; i &lt; 256; i++) {</b>
<b class="nc">&nbsp;				if (zIndex.get(i) != null) {</b>
<b class="nc">&nbsp;					sb.append(String.format(&quot;    * %d -&gt; &quot;, i - 127));</b>
&nbsp;
<b class="nc">&nbsp;					HashSet&lt;StyleGroup&gt; map = zIndex.get(i);</b>
&nbsp;
<b class="nc">&nbsp;					for (StyleGroup g : map)</b>
<b class="nc">&nbsp;						sb.append(String.format(&quot;%s &quot;, g.getId()));</b>
&nbsp;
<b class="nc">&nbsp;					sb.append(String.format(&quot;%n&quot;));</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return sb.toString();</b>
&nbsp;		}
&nbsp;
&nbsp;		public class ZIndexIterator implements Iterator&lt;HashSet&lt;StyleGroup&gt;&gt; {
<b class="nc">&nbsp;			public int index = 0;</b>
&nbsp;
<b class="nc">&nbsp;			public ZIndexIterator() {</b>
<b class="nc">&nbsp;				zapUntilACell();</b>
&nbsp;			}
&nbsp;
&nbsp;			protected void zapUntilACell() {
<b class="nc">&nbsp;				while (index &lt; 256 &amp;&amp; zIndex.get(index) == null)</b>
<b class="nc">&nbsp;					index++;</b>
&nbsp;			}
&nbsp;
&nbsp;			public boolean hasNext() {
<b class="nc">&nbsp;				return (index &lt; 256);</b>
&nbsp;			}
&nbsp;
&nbsp;			public HashSet&lt;StyleGroup&gt; next() {
<b class="nc">&nbsp;				if (hasNext()) {</b>
<b class="nc">&nbsp;					HashSet&lt;StyleGroup&gt; cell = zIndex.get(index);</b>
<b class="nc">&nbsp;					index++;</b>
<b class="nc">&nbsp;					zapUntilACell();</b>
<b class="nc">&nbsp;					return cell;</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void remove() {
<b class="nc">&nbsp;				throw new RuntimeException(&quot;This iterator does not support removal.&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set of groups that cast a shadow.
&nbsp;	 * 
&nbsp;	 * @author Antoine Dutot
&nbsp;	 */
<b class="nc">&nbsp;	public class ShadowSet implements Iterable&lt;StyleGroup&gt; {</b>
&nbsp;		/**
&nbsp;		 * The set of groups casting shadow.
&nbsp;		 */
<b class="nc">&nbsp;		protected HashSet&lt;StyleGroup&gt; shadowSet = new HashSet&lt;StyleGroup&gt;();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Iterator on the set of groups that cast a shadow.
&nbsp;		 * 
&nbsp;		 * @return An iterator on the shadow style group set.
&nbsp;		 */
&nbsp;		protected Iterator&lt;StyleGroup&gt; getIterator() {
<b class="nc">&nbsp;			return shadowSet.iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Iterator&lt;StyleGroup&gt; iterator() {
<b class="nc">&nbsp;			return getIterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A group appeared, check its shadow status.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group added.
&nbsp;		 */
&nbsp;		protected void groupAdded(StyleGroup group) {
<b class="nc">&nbsp;			if (group.getShadowMode() != ShadowMode.NONE)</b>
<b class="nc">&nbsp;				shadowSet.add(group);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A group eventually changed, check its shadow status.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group that changed.
&nbsp;		 */
&nbsp;		protected void groupChanged(StyleGroup group) {
<b class="nc">&nbsp;			if (group.getShadowMode() == ShadowMode.NONE)</b>
<b class="nc">&nbsp;				shadowSet.remove(group);</b>
&nbsp;			else
<b class="nc">&nbsp;				shadowSet.add(group);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * A group was removed, remove it from the shadow if needed.
&nbsp;		 * 
&nbsp;		 * @param group
&nbsp;		 *            The group removed.
&nbsp;		 */
&nbsp;		protected void groupRemoved(StyleGroup group) {
&nbsp;			// Faster than to first test its existence or shadow status :
&nbsp;
<b class="nc">&nbsp;			shadowSet.remove(group);</b>
&nbsp;		}
&nbsp;
&nbsp;		protected void clear() {
<b class="nc">&nbsp;			shadowSet.clear();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Iterator that allows to browse all graph elements of a given kind (nodes,
&nbsp;	 * edges, sprites, graphs) as if they where in a single set, whereas they are in
&nbsp;	 * style groups.
&nbsp;	 * 
&nbsp;	 * @author Antoine Dutot
&nbsp;	 * @param &lt;E&gt;
&nbsp;	 *            The kind of graph element.
&nbsp;	 */
&nbsp;	protected class ElementIterator&lt;E extends Element&gt; implements Iterator&lt;E&gt; {
&nbsp;		protected Map&lt;String, String&gt; elt2grp;
&nbsp;
&nbsp;		protected Iterator&lt;String&gt; elts;
&nbsp;
<b class="nc">&nbsp;		public ElementIterator(final Map&lt;String, String&gt; elements2groups) {</b>
<b class="nc">&nbsp;			elt2grp = elements2groups;</b>
<b class="nc">&nbsp;			elts = elements2groups.keySet().iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasNext() {
<b class="nc">&nbsp;			return elts.hasNext();</b>
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		public E next() {
<b class="nc">&nbsp;			String eid = elts.next();</b>
<b class="nc">&nbsp;			String gid = elt2grp.get(eid);</b>
<b class="nc">&nbsp;			StyleGroup grp = groups.get(gid);</b>
&nbsp;
<b class="nc">&nbsp;			return (E) grp.getElement(eid);</b>
&nbsp;		}
&nbsp;
&nbsp;		public void remove() {
<b class="nc">&nbsp;			throw new RuntimeException(&quot;remove not implemented in this iterator&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Dummy set of nodes.
&nbsp;	 */
<b class="nc">&nbsp;	protected class NodeSet implements Iterable&lt;Node&gt; {</b>
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		public Iterator&lt;Node&gt; iterator() {
<b class="nc">&nbsp;			return (Iterator&lt;Node&gt;) getNodeIterator();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Dummy set of edges.
&nbsp;	 */
<b class="nc">&nbsp;	protected class EdgeSet implements Iterable&lt;Edge&gt; {</b>
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		public Iterator&lt;Edge&gt; iterator() {
<b class="nc">&nbsp;			return (Iterator&lt;Edge&gt;) getEdgeIterator();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Dummy set of sprites.
&nbsp;	 */
<b class="nc">&nbsp;	protected class SpriteSet implements Iterable&lt;GraphicSprite&gt; {</b>
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		public Iterator&lt;GraphicSprite&gt; iterator() {
<b class="nc">&nbsp;			return (Iterator&lt;GraphicSprite&gt;) getSpriteIterator();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	protected class GraphSet implements Iterable&lt;GraphicGraph&gt; {</b>
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		public Iterator&lt;GraphicGraph&gt; iterator() {
<b class="nc">&nbsp;			return (Iterator&lt;GraphicGraph&gt;) getGraphIterator();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-07-08 16:57</div>
</div>
</body>
</html>
