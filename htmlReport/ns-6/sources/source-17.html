


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FileSourceGEXF</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.graphstream.stream.file</a>
</div>

<h1>Coverage Summary for Class: FileSourceGEXF (org.graphstream.stream.file)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FileSourceGEXF</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FileSourceGEXF$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$Attribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$ATTRIBUTEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$ATTRIBUTESAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$AttributeType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$ATTVALUEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$Balise</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$ClassType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$COLORAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$EDGEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$EDGESAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$EDGESHAPEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$EdgeShapeType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$EdgeType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$GEXFAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$GRAPHAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$IDType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$METAAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$ModeType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$NODEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$NODESAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$NODESHAPEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$NodeShapeType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$PARENTAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$POSITIONAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$SIZEAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$SPELLAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$THICKNESSAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$TimeFormatType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFConstants$WeightType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileSourceGEXF$GEXFParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/415)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/518)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
&nbsp; * 
&nbsp; * GraphStream is a library whose purpose is to handle static or dynamic
&nbsp; * graph, create them from scratch, file or any source and display them.
&nbsp; * 
&nbsp; * This program is free software distributed under the terms of two licenses, the
&nbsp; * CeCILL-C license that fits European law, and the GNU Lesser General Public
&nbsp; * License. You can  use, modify and/ or redistribute the software under the terms
&nbsp; * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
&nbsp; * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or (at your
&nbsp; * option) any later version.
&nbsp; * 
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT ANY
&nbsp; * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
&nbsp; * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
&nbsp; * 
&nbsp; * You should have received a copy of the GNU Lesser General Public License
&nbsp; * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; * 
&nbsp; * The fact that you are presently reading this means that you have had
&nbsp; * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * @since 2011-09-21
&nbsp; * 
&nbsp; * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
&nbsp; * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
&nbsp; */
&nbsp;package org.graphstream.stream.file;
&nbsp;
&nbsp;import java.awt.Color;
&nbsp;import java.io.IOException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.util.EnumMap;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import javax.xml.stream.XMLStreamException;
&nbsp;import javax.xml.stream.events.XMLEvent;
&nbsp;
&nbsp;/**
&nbsp; * File source for the &lt;a href=&quot;http://gexf.net/format/&quot;&gt;GEXF&lt;/a&gt; file format
&nbsp; * used by &lt;a href=&quot;http://www.gephi.org&quot;&gt;Gephi&lt;/a&gt;.
&nbsp; *
&nbsp; * @author Guilhelm Savin
&nbsp; */
<b class="nc">&nbsp;public class FileSourceGEXF extends FileSourceXML {</b>
<b class="nc">&nbsp;	private static final Pattern IS_DOUBLE = Pattern.compile(&quot;^-?\\d+([.]\\d+)?$&quot;);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The GEXF parser.
&nbsp;	 */
&nbsp;	protected GEXFParser parser;
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 *
&nbsp;	 * @see org.graphstream.stream.file.FileSourceXML#afterStartDocument()
&nbsp;	 */
&nbsp;	protected void afterStartDocument() throws IOException, XMLStreamException {
<b class="nc">&nbsp;		parser = new GEXFParser();</b>
<b class="nc">&nbsp;		parser.__gexf();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 *
&nbsp;	 * @see org.graphstream.stream.file.FileSourceXML#nextEvents()
&nbsp;	 */
&nbsp;	public boolean nextEvents() throws IOException {
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * (non-Javadoc)
&nbsp;	 *
&nbsp;	 * @see org.graphstream.stream.file.FileSourceXML#beforeEndDocument()
&nbsp;	 */
&nbsp;	protected void beforeEndDocument() {
<b class="nc">&nbsp;		parser = null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;unused&quot;)
&nbsp;	private class Attribute implements GEXFConstants {
&nbsp;		final String id;
&nbsp;		final String title;
&nbsp;		final AttributeType type;
&nbsp;		Object def;
&nbsp;		String options;
&nbsp;
<b class="nc">&nbsp;		Attribute(String id, String title, AttributeType type) {</b>
<b class="nc">&nbsp;			this.id = id;</b>
<b class="nc">&nbsp;			this.title = title;</b>
<b class="nc">&nbsp;			this.type = type;</b>
&nbsp;		}
&nbsp;
&nbsp;		Object getValue(String value) {
&nbsp;			Object r;
&nbsp;
<b class="nc">&nbsp;			switch (type) {</b>
&nbsp;			case INTEGER:
<b class="nc">&nbsp;				r = Integer.valueOf(value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case LONG:
<b class="nc">&nbsp;				r = Long.valueOf(value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case FLOAT:
<b class="nc">&nbsp;				r = Float.valueOf(value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case DOUBLE:
<b class="nc">&nbsp;				r = Double.valueOf(value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case BOOLEAN:
<b class="nc">&nbsp;				r = Boolean.valueOf(value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case LISTSTRING:
<b class="nc">&nbsp;				String[] list = value.split(&quot;\\|&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				boolean isDouble = true;</b>
&nbsp;
<b class="nc">&nbsp;				for (int i = 0; i &lt; list.length; i++)</b>
<b class="nc">&nbsp;					isDouble = isDouble &amp;&amp; IS_DOUBLE.matcher(list[i]).matches();</b>
&nbsp;
<b class="nc">&nbsp;				if (isDouble) {</b>
<b class="nc">&nbsp;					double[] dlist = new double[list.length];</b>
&nbsp;
<b class="nc">&nbsp;					for (int i = 0; i &lt; list.length; i++)</b>
<b class="nc">&nbsp;						dlist[i] = Double.parseDouble(list[i]);</b>
&nbsp;
<b class="nc">&nbsp;					r = dlist;</b>
<b class="nc">&nbsp;				} else</b>
<b class="nc">&nbsp;					r = list;</b>
&nbsp;
<b class="nc">&nbsp;				break;</b>
&nbsp;			case ANYURI:
&nbsp;				try {
<b class="nc">&nbsp;					r = new URI(value);</b>
<b class="nc">&nbsp;				} catch (URISyntaxException e) {</b>
<b class="nc">&nbsp;					throw new IllegalArgumentException(e);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;				break;
&nbsp;			default:
<b class="nc">&nbsp;				r = value;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return r;</b>
&nbsp;		}
&nbsp;
&nbsp;		void setDefault(String value) {
<b class="nc">&nbsp;			this.def = getValue(value);</b>
&nbsp;		}
&nbsp;
&nbsp;		void setOptions(String options) {
<b class="nc">&nbsp;			this.options = options;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private class GEXFParser extends Parser implements GEXFConstants {</b>
&nbsp;		EdgeType defaultEdgeType;
&nbsp;		TimeFormatType timeFormat;
&nbsp;		HashMap&lt;String, Attribute&gt; nodeAttributesDefinition;
&nbsp;		HashMap&lt;String, Attribute&gt; edgeAttributesDefinition;
&nbsp;
<b class="nc">&nbsp;		GEXFParser() {</b>
<b class="nc">&nbsp;			defaultEdgeType = EdgeType.UNDIRECTED;</b>
<b class="nc">&nbsp;			timeFormat = TimeFormatType.INTEGER;</b>
<b class="nc">&nbsp;			nodeAttributesDefinition = new HashMap&lt;String, Attribute&gt;();</b>
<b class="nc">&nbsp;			edgeAttributesDefinition = new HashMap&lt;String, Attribute&gt;();</b>
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unused&quot;)
&nbsp;		private long getTime(String time) {
<b class="nc">&nbsp;			long t = 0;</b>
&nbsp;
<b class="nc">&nbsp;			switch (timeFormat) {</b>
&nbsp;			case INTEGER:
<b class="nc">&nbsp;				t = Integer.valueOf(time);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case DOUBLE:
&nbsp;				// TODO
<b class="nc">&nbsp;				break;</b>
&nbsp;			case DATE:
&nbsp;				// TODO
<b class="nc">&nbsp;				break;</b>
&nbsp;			case DATETIME:
&nbsp;				// TODO
&nbsp;				break;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return t;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * name : GEXF attributes : GEXFAttribute structure : META ? GRAPH
&nbsp;		 */
&nbsp;		private void __gexf() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;gexf&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;meta&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
<b class="nc">&nbsp;				__meta();</b>
&nbsp;			} else
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;			__graph();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;gexf&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * name : META attributes : METAttribute structure : ( CREATOR | KEYWORDS |
&nbsp;		 * DESCRIPTION )*
&nbsp;		 */
&nbsp;		private void __meta() throws IOException, XMLStreamException {
&nbsp;			EnumMap&lt;METAAttribute, String&gt; attributes;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;meta&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(METAAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(METAAttribute.LASTMODIFIEDDATE))</b>
<b class="nc">&nbsp;				sendGraphAttributeAdded(sourceId, &quot;lastmodifieddate&quot;, attributes.get(METAAttribute.LASTMODIFIEDDATE));</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (!isEvent(e, XMLEvent.END_ELEMENT, &quot;meta&quot;)) {</b>
&nbsp;				try {
&nbsp;					String str;
<b class="nc">&nbsp;					Balise b = Balise.valueOf(toConstantName(e.asStartElement().getName().getLocalPart()));</b>
&nbsp;
<b class="nc">&nbsp;					pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;					switch (b) {</b>
&nbsp;					case CREATOR:
<b class="nc">&nbsp;						str = __creator();</b>
<b class="nc">&nbsp;						sendGraphAttributeAdded(sourceId, &quot;creator&quot;, str);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case KEYWORDS:
<b class="nc">&nbsp;						str = __keywords();</b>
<b class="nc">&nbsp;						sendGraphAttributeAdded(sourceId, &quot;keywords&quot;, str);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case DESCRIPTION:
<b class="nc">&nbsp;						str = __description();</b>
<b class="nc">&nbsp;						sendGraphAttributeAdded(sourceId, &quot;description&quot;, str);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					default:
<b class="nc">&nbsp;						newParseError(e, false, &quot;meta children should be one of &#39;creator&#39;,&#39;keywords&#39; or &#39;description&#39;&quot;);</b>
&nbsp;					}
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;unknown element &#39;%s&#39;&quot;, e.asStartElement().getName().getLocalPart());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;meta&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * name : CREATOR attributes : structure : string
&nbsp;		 */
&nbsp;		private String __creator() throws IOException, XMLStreamException {
&nbsp;			String creator;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;creator&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			creator = __characters();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;creator&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return creator;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * name : KEYWORDS attributes : structure : string
&nbsp;		 */
&nbsp;		private String __keywords() throws IOException, XMLStreamException {
&nbsp;			String keywords;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;keywords&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			keywords = __characters();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;keywords&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return keywords;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: DESCRIPTION
&nbsp;		 * attributes 	:
&nbsp;		 * structure 	: string
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private String __description() throws IOException, XMLStreamException {
&nbsp;			String description;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;description&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			description = __characters();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;description&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return description;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: GRAPH
&nbsp;		 * attributes 	: GRAPHAttribute
&nbsp;		 * structure 	: ATTRIBUTES * ( NODES | EDGES )*
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __graph() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;GRAPHAttribute, String&gt; attributes;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;graph&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(GRAPHAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(GRAPHAttribute.DEFAULTEDGETYPE)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					defaultEdgeType = EdgeType.valueOf(toConstantName(attributes.get(GRAPHAttribute.DEFAULTEDGETYPE)));</b>
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true,</b>
&nbsp;							&quot;&#39;defaultedgetype&#39; value should be one of &#39;directed&#39;, &#39;undirected&#39; or &#39;mutual&#39;&quot;);
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(GRAPHAttribute.TIMEFORMAT)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					timeFormat = TimeFormatType.valueOf(toConstantName(attributes.get(GRAPHAttribute.TIMEFORMAT)));</b>
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true,</b>
&nbsp;							&quot;&#39;timeformat&#39; value should be one of &#39;integer&#39;, &#39;double&#39;, &#39;date&#39; or &#39;datetime&#39;&quot;);
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;attributes&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__attributes();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;nodes&quot;) || isEvent(e, XMLEvent.START_ELEMENT, &quot;edges&quot;)) {</b>
<b class="nc">&nbsp;				if (isEvent(e, XMLEvent.START_ELEMENT, &quot;nodes&quot;)) {</b>
<b class="nc">&nbsp;					pushback(e);</b>
<b class="nc">&nbsp;					__nodes();</b>
&nbsp;				} else {
<b class="nc">&nbsp;					pushback(e);</b>
<b class="nc">&nbsp;					__edges();</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;graph&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: ATTRIBUTES
&nbsp;		 * attributes 	: ATTRIBUTESAttributes { CLASS!, MODE, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: ATTRIBUTE *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __attributes() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;ATTRIBUTESAttribute, String&gt; attributes;
&nbsp;			Attribute a;
<b class="nc">&nbsp;			ClassType type = null;</b>
&nbsp;			HashMap&lt;String, Attribute&gt; attr;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;attributes&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(ATTRIBUTESAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, ATTRIBUTESAttribute.CLASS);</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				type = ClassType.valueOf(toConstantName(attributes.get(ATTRIBUTESAttribute.CLASS)));</b>
<b class="nc">&nbsp;			} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;				newParseError(e, true, &quot;&#39;class&#39; value shoudl be one of &#39;node&#39; or &#39;edge&#39;&quot;);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			if (type == ClassType.NODE)</b>
<b class="nc">&nbsp;				attr = nodeAttributesDefinition;</b>
&nbsp;			else
<b class="nc">&nbsp;				attr = edgeAttributesDefinition;</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;attribute&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				a = __attribute();</b>
<b class="nc">&nbsp;				attr.put(a.id, a);</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;attributes&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: ATTRIBUTE
&nbsp;		 * attributes 	: ATTRIBUTEAttribute { ID, TITLE, TYPE }
&nbsp;		 * structure 	: ( DEFAULT | OPTIONS ) *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private Attribute __attribute() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;ATTRIBUTEAttribute, String&gt; attributes;
&nbsp;			String id, title;
<b class="nc">&nbsp;			AttributeType type = null;</b>
&nbsp;			Attribute theAttribute;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;attribute&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(ATTRIBUTEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, ATTRIBUTEAttribute.ID, ATTRIBUTEAttribute.TITLE,</b>
&nbsp;					ATTRIBUTEAttribute.TYPE);
&nbsp;
<b class="nc">&nbsp;			id = attributes.get(ATTRIBUTEAttribute.ID);</b>
<b class="nc">&nbsp;			title = attributes.get(ATTRIBUTEAttribute.TITLE);</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				type = AttributeType.valueOf(toConstantName(attributes.get(ATTRIBUTEAttribute.TYPE)));</b>
<b class="nc">&nbsp;			} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;				newParseError(e, true,</b>
&nbsp;						&quot;&#39;type&#39; of attribute should be one of &#39;integer&#39;, &#39;long&#39;, &#39;float, &#39;double&#39;, &#39;string&#39;, &#39;liststring&#39;, &#39;anyURI&#39; or &#39;boolean&#39;&quot;);
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			theAttribute = new Attribute(id, title, type);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (!isEvent(e, XMLEvent.END_ELEMENT, &quot;attribute&quot;)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					Balise b = Balise.valueOf(toConstantName(e.asStartElement().getName().getLocalPart()));</b>
&nbsp;
<b class="nc">&nbsp;					pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;					switch (b) {</b>
&nbsp;					case DEFAULT:
&nbsp;						try {
<b class="nc">&nbsp;							theAttribute.setDefault(__default());</b>
<b class="nc">&nbsp;						} catch (Exception invalid) {</b>
<b class="nc">&nbsp;							newParseError(e, false, &quot;invalid &#39;default&#39; value&quot;);</b>
<b class="nc">&nbsp;						}</b>
&nbsp;
<b class="nc">&nbsp;						break;</b>
&nbsp;					case OPTIONS:
<b class="nc">&nbsp;						theAttribute.setOptions(__options());</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					default:
<b class="nc">&nbsp;						newParseError(e, true, &quot;attribute children should be one of &#39;default&#39; or &#39;options&#39;&quot;);</b>
&nbsp;					}
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;unknown element &#39;%s&#39;&quot;, e.asStartElement().getName().getLocalPart());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;attribute&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return theAttribute;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: DEFAULT
&nbsp;		 * attributes 	:
&nbsp;		 * structure 	: string
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private String __default() throws IOException, XMLStreamException {
&nbsp;			String def;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;default&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			def = __characters();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;default&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return def;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: OPTIONS
&nbsp;		 * attributes 	:
&nbsp;		 * structure 	: string
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private String __options() throws IOException, XMLStreamException {
&nbsp;			String options;
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			options = __characters();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return options;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: NODES
&nbsp;		 * attributes 	: NODESAttribute { &#39;count&#39; }
&nbsp;		 * structure 	: NODE *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __nodes() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;nodes&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;node&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__node();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;nodes&quot;);</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: NODE
&nbsp;		 * attributes 	: NODEAttribute { &#39;pid&#39;, &#39;id&#39;, &#39;label&#39;, &#39;start&#39;, &#39;startopen&#39;, &#39;end&#39;, &#39;endopen&#39; }
&nbsp;		 * structure 	: ( ATTVALUES | SPELLS | ( NODES | EDGES ) | PARENTS | ( COLOR | POSITION | SIZE | NODESHAPE ) ) *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __node() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;NODEAttribute, String&gt; attributes;
&nbsp;			String id;
<b class="nc">&nbsp;			HashSet&lt;String&gt; defined = new HashSet&lt;String&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;node&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(NODEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, NODEAttribute.ID);</b>
&nbsp;
<b class="nc">&nbsp;			id = attributes.get(NODEAttribute.ID);</b>
<b class="nc">&nbsp;			sendNodeAdded(sourceId, id);</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(NODEAttribute.LABEL))</b>
<b class="nc">&nbsp;				sendNodeAttributeAdded(sourceId, id, &quot;label&quot;, attributes.get(NODEAttribute.LABEL));</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (!isEvent(e, XMLEvent.END_ELEMENT, &quot;node&quot;)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					Balise b = Balise.valueOf(toConstantName(e.asStartElement().getName().getLocalPart()));</b>
&nbsp;
<b class="nc">&nbsp;					pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;					switch (b) {</b>
&nbsp;					case ATTVALUES:
<b class="nc">&nbsp;						defined.addAll(__attvalues(ClassType.NODE, id));</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case COLOR:
<b class="nc">&nbsp;						__color(ClassType.NODE, id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case POSITION:
<b class="nc">&nbsp;						__position(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case SIZE:
<b class="nc">&nbsp;						__size(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case SHAPE:
<b class="nc">&nbsp;						__node_shape(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case SPELLS:
<b class="nc">&nbsp;						__spells();</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case NODES:
<b class="nc">&nbsp;						__nodes();</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case EDGES:
<b class="nc">&nbsp;						__edges();</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case PARENTS:
<b class="nc">&nbsp;						__parents(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					default:
<b class="nc">&nbsp;						newParseError(e, true,</b>
&nbsp;								&quot;attribute children should be one of &#39;attvalues&#39;, &#39;color&#39;, &#39;position&#39;, &#39;size&#39;, shape&#39;, &#39;spells&#39;, &#39;nodes, &#39;edges&#39; or &#39;parents&#39;&quot;);
&nbsp;					}
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;unknown element &#39;%s&#39;&quot;, e.asStartElement().getName().getLocalPart());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			for (Attribute theAttribute : nodeAttributesDefinition.values()) {</b>
<b class="nc">&nbsp;				if (!defined.contains(theAttribute.id)) {</b>
<b class="nc">&nbsp;					sendNodeAttributeAdded(sourceId, id, theAttribute.title, theAttribute.def);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;node&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name : ATTVALUES attributes : structure : ATTVALUE * &lt;/spell&gt;
&nbsp;		 */
&nbsp;		private HashSet&lt;String&gt; __attvalues(ClassType type, String elementId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
<b class="nc">&nbsp;			HashSet&lt;String&gt; defined = new HashSet&lt;String&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;attvalues&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;attvalue&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				defined.add(__attvalue(type, elementId));</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;attvalues&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return defined;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: ATTVALUE
&nbsp;		 * attributes 	: ATTVALUEAttribute { FOR!, VALUE!, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	:
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private String __attvalue(ClassType type, String elementId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;ATTVALUEAttribute, String&gt; attributes;
&nbsp;			Attribute theAttribute;
<b class="nc">&nbsp;			Object value = null;</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;attvalue&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(ATTVALUEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, ATTVALUEAttribute.FOR, ATTVALUEAttribute.VALUE);</b>
&nbsp;
<b class="nc">&nbsp;			if (type == ClassType.NODE)</b>
<b class="nc">&nbsp;				theAttribute = nodeAttributesDefinition.get(attributes.get(ATTVALUEAttribute.FOR));</b>
&nbsp;			else
<b class="nc">&nbsp;				theAttribute = edgeAttributesDefinition.get(attributes.get(ATTVALUEAttribute.FOR));</b>
&nbsp;
<b class="nc">&nbsp;			if (theAttribute == null)</b>
<b class="nc">&nbsp;				newParseError(e, false, &quot;undefined attribute \&quot;%s\&quot;&quot;, attributes.get(ATTVALUEAttribute.FOR));</b>
&nbsp;			else {
&nbsp;				try {
<b class="nc">&nbsp;					value = theAttribute.getValue(attributes.get(ATTVALUEAttribute.VALUE));</b>
<b class="nc">&nbsp;				} catch (Exception ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;invalid &#39;value&#39; value&quot;);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				switch (type) {</b>
&nbsp;				case NODE:
<b class="nc">&nbsp;					sendNodeAttributeAdded(sourceId, elementId, theAttribute.title, value);</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				case EDGE:
<b class="nc">&nbsp;					sendEdgeAttributeAdded(sourceId, elementId, theAttribute.title, value);</b>
&nbsp;					break;
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;attvalue&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			return theAttribute == null ? null : theAttribute.id;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: SPELLS
&nbsp;		 * attributes 	:
&nbsp;		 * structure 	: SPELL +
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __spells() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;spells&quot;);</b>
&nbsp;
&nbsp;			do {
<b class="nc">&nbsp;				__spell();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
<b class="nc">&nbsp;			} while (isEvent(e, XMLEvent.START_ELEMENT, &quot;spell&quot;));</b>
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;spells&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: SPELL
&nbsp;		 * attributes 	: SPELLAttribute
&nbsp;		 * structure 	:
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		@SuppressWarnings(&quot;unused&quot;)
&nbsp;		private void __spell() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;SPELLAttribute, String&gt; attributes;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;spell&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(SPELLAttribute.class, e.asStartElement());</b>
&nbsp;
&nbsp;			// TODO Handle spell
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;spell&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: PARENTS
&nbsp;		 * attributes 	:
&nbsp;		 * structure 	: PARENT *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __parents(String nodeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;parents&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;parent&quot;)) {</b>
<b class="nc">&nbsp;				__parent(nodeId);</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;parents&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: PARENT
&nbsp;		 * attributes 	: PARENTAttribute { FOR! }
&nbsp;		 * structure 	:
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __parent(String nodeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;PARENTAttribute, String&gt; attributes;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;parent&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(PARENTAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, PARENTAttribute.FOR);</b>
<b class="nc">&nbsp;			sendNodeAttributeAdded(sourceId, attributes.get(PARENTAttribute.FOR), &quot;parent&quot;, nodeId);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;parent&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: COLOR
&nbsp;		 * attributes 	: COLORAttribute { R!, G!, B!, A, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __color(ClassType type, String id) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;COLORAttribute, String&gt; attributes;
&nbsp;			Color color;
<b class="nc">&nbsp;			int r, g, b, a = 255;</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;color&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(COLORAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, COLORAttribute.R, COLORAttribute.G, COLORAttribute.B);</b>
&nbsp;
<b class="nc">&nbsp;			r = Integer.valueOf(attributes.get(COLORAttribute.R));</b>
<b class="nc">&nbsp;			g = Integer.valueOf(attributes.get(COLORAttribute.G));</b>
<b class="nc">&nbsp;			b = Integer.valueOf(attributes.get(COLORAttribute.B));</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(COLORAttribute.A))</b>
<b class="nc">&nbsp;				a = Integer.valueOf(attributes.get(COLORAttribute.A));</b>
&nbsp;
<b class="nc">&nbsp;			color = new Color(r, g, b, a);</b>
&nbsp;
<b class="nc">&nbsp;			switch (type) {</b>
&nbsp;			case NODE:
<b class="nc">&nbsp;				sendNodeAttributeAdded(sourceId, id, &quot;ui.color&quot;, color);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case EDGE:
<b class="nc">&nbsp;				sendEdgeAttributeAdded(sourceId, id, &quot;ui.color&quot;, color);</b>
&nbsp;				break;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;color&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: POSITION
&nbsp;		 * attributes 	: POSITIONAttribute { X!, Y!, Z!, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __position(String nodeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;POSITIONAttribute, String&gt; attributes;
<b class="nc">&nbsp;			double[] xyz = { 0, 0, 0 };</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;position&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(POSITIONAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, POSITIONAttribute.X, POSITIONAttribute.Y, POSITIONAttribute.Z);</b>
&nbsp;
<b class="nc">&nbsp;			xyz[0] = Double.valueOf(attributes.get(POSITIONAttribute.X));</b>
<b class="nc">&nbsp;			xyz[1] = Double.valueOf(attributes.get(POSITIONAttribute.Y));</b>
<b class="nc">&nbsp;			xyz[2] = Double.valueOf(attributes.get(POSITIONAttribute.Z));</b>
&nbsp;
<b class="nc">&nbsp;			sendNodeAttributeAdded(sourceId, nodeId, &quot;xyz&quot;, xyz);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;position&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: SIZE
&nbsp;		 * attributes 	: SIZEAttribute { VALUE!, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __size(String nodeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;SIZEAttribute, String&gt; attributes;
&nbsp;			double value;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;size&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(SIZEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, SIZEAttribute.VALUE);</b>
&nbsp;
<b class="nc">&nbsp;			value = Double.valueOf(attributes.get(SIZEAttribute.VALUE));</b>
&nbsp;
<b class="nc">&nbsp;			sendNodeAttributeAdded(sourceId, nodeId, &quot;ui.size&quot;, value);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;size&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: NODESHAPE
&nbsp;		 * attributes 	: NODESHAPEAttributes { VALUE!, URI, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __node_shape(String nodeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;NODESHAPEAttribute, String&gt; attributes;
<b class="nc">&nbsp;			NodeShapeType type = null;</b>
&nbsp;			String uri;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;shape&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(NODESHAPEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, NODESHAPEAttribute.VALUE);</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				type = NodeShapeType.valueOf(toConstantName(attributes.get(NODESHAPEAttribute.VALUE)));</b>
<b class="nc">&nbsp;			} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;				newParseError(e, true, &quot;&#39;value&#39; should be one of &#39;disc&#39;, &#39;diamond&#39;, &#39;triangle&#39;, &#39;square&#39; or &#39;image&#39;&quot;);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			switch (type) {</b>
&nbsp;			case IMAGE:
<b class="nc">&nbsp;				if (!attributes.containsKey(NODESHAPEAttribute.URI))</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;&#39;image&#39; shape type needs &#39;uri&#39; attribute&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				uri = attributes.get(NODESHAPEAttribute.URI);</b>
<b class="nc">&nbsp;				sendNodeAttributeAdded(sourceId, nodeId, &quot;ui.style&quot;,</b>
<b class="nc">&nbsp;						String.format(&quot;fill-mode: image-scaled; fill-image: url(&#39;%s&#39;);&quot;, uri));</b>
&nbsp;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				sendNodeAttributeAdded(sourceId, nodeId, &quot;ui.style&quot;,</b>
<b class="nc">&nbsp;						String.format(&quot;shape: %s;&quot;, type.name().toLowerCase()));</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;shape&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: EDGES
&nbsp;		 * attributes 	: EDGESAttribute { &#39;count&#39; }
&nbsp;		 * structure 	: EDGE *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __edges() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;edges&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (isEvent(e, XMLEvent.START_ELEMENT, &quot;edge&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__edge();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;edges&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: EDGE
&nbsp;		 * attributes 	: EDGEAttribute { START, STARTOPEN, END, ENDOPEN, ID!, TYPE, LABEL, SOURCE!, TARGET!, WEIGHT }
&nbsp;		 * structure 	: ( ATTVALUES | SPELLS | ( COLOR | THICKNESS | EDGESHAPE ) ) *
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __edge() throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;EDGEAttribute, String&gt; attributes;
&nbsp;			String id, source, target;
<b class="nc">&nbsp;			EdgeType type = defaultEdgeType;</b>
<b class="nc">&nbsp;			HashSet&lt;String&gt; defined = new HashSet&lt;String&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;edge&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(EDGEAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, EDGEAttribute.ID, EDGEAttribute.SOURCE, EDGEAttribute.TARGET);</b>
&nbsp;
<b class="nc">&nbsp;			id = attributes.get(EDGEAttribute.ID);</b>
<b class="nc">&nbsp;			source = attributes.get(EDGEAttribute.SOURCE);</b>
<b class="nc">&nbsp;			target = attributes.get(EDGEAttribute.TARGET);</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(EDGEAttribute.TYPE)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					type = EdgeType.valueOf(toConstantName(attributes.get(EDGEAttribute.TYPE)));</b>
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;edge type should be one of &#39;undirected&#39;, &#39;undirected&#39; or &#39;mutual&#39;&quot;);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			switch (type) {</b>
&nbsp;			case DIRECTED:
<b class="nc">&nbsp;				sendEdgeAdded(sourceId, id, source, target, true);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case MUTUAL:
&nbsp;			case UNDIRECTED:
<b class="nc">&nbsp;				sendEdgeAdded(sourceId, id, source, target, false);</b>
&nbsp;				break;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(EDGEAttribute.LABEL))</b>
<b class="nc">&nbsp;				sendEdgeAttributeAdded(sourceId, id, &quot;ui.label&quot;, attributes.get(EDGEAttribute.LABEL));</b>
&nbsp;
<b class="nc">&nbsp;			if (attributes.containsKey(EDGEAttribute.WEIGHT)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					double d = Double.valueOf(attributes.get(EDGEAttribute.WEIGHT));</b>
<b class="nc">&nbsp;					sendEdgeAttributeAdded(sourceId, id, &quot;weight&quot;, d);</b>
<b class="nc">&nbsp;				} catch (NumberFormatException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;&#39;weight&#39; attribute of edge should be a real&quot;);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			while (!isEvent(e, XMLEvent.END_ELEMENT, &quot;edge&quot;)) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					Balise b = Balise.valueOf(toConstantName(e.asStartElement().getName().getLocalPart()));</b>
&nbsp;
<b class="nc">&nbsp;					pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;					switch (b) {</b>
&nbsp;					case ATTVALUES:
<b class="nc">&nbsp;						defined.addAll(__attvalues(ClassType.EDGE, id));</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case SPELLS:
<b class="nc">&nbsp;						__spells();</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case COLOR:
<b class="nc">&nbsp;						__color(ClassType.EDGE, id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case THICKNESS:
<b class="nc">&nbsp;						__thickness(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					case SHAPE:
<b class="nc">&nbsp;						__edge_shape(id);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					default:
<b class="nc">&nbsp;						newParseError(e, true,</b>
&nbsp;								&quot;edge children should be one of &#39;attvalues&#39;, &#39;color&#39;, &#39;thicknes&#39;, &#39;shape&#39; or &#39;spells&#39;&quot;);
&nbsp;					}
<b class="nc">&nbsp;				} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;					newParseError(e, true, &quot;unknown tag &#39;%s&#39;&quot;, e.asStartElement().getName().getLocalPart());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			for (String key : edgeAttributesDefinition.keySet()) {</b>
<b class="nc">&nbsp;				if (!defined.contains(key))</b>
<b class="nc">&nbsp;					sendEdgeAttributeAdded(sourceId, id, key, edgeAttributesDefinition.get(key).def);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;edge&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: EDGESHAPE
&nbsp;		 * attributes 	: EDGESHAPEAttributes { VALUE!, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		@SuppressWarnings(&quot;unused&quot;)
&nbsp;		private void __edge_shape(String edgeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;EDGESHAPEAttribute, String&gt; attributes;
&nbsp;			EdgeShapeType type;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;shape&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(EDGESHAPEAttribute.class, e.asStartElement());</b>
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, EDGESHAPEAttribute.VALUE);</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				type = EdgeShapeType.valueOf(toConstantName(attributes.get(EDGESHAPEAttribute.VALUE)));</b>
<b class="nc">&nbsp;			} catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;				newParseError(e, true, &quot;&#39;value&#39; of shape should be one of &#39;solid&#39;, &#39;dotted&#39;, &#39;dashed&#39; or &#39;double&#39;&quot;);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;			// TODO Handle shape of edges
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;shape&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * &lt;pre&gt;
&nbsp;		 * name 		: THICKNESS
&nbsp;		 * attributes 	: THICKNESSAttribute { VALUE!, START, STARTOPEN, END, ENDOPEN }
&nbsp;		 * structure 	: SPELLS ?
&nbsp;		 * &lt;/pre&gt;
&nbsp;		 */
&nbsp;		private void __thickness(String edgeId) throws IOException, XMLStreamException {
&nbsp;			XMLEvent e;
&nbsp;			EnumMap&lt;THICKNESSAttribute, String&gt; attributes;
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
<b class="nc">&nbsp;			checkValid(e, XMLEvent.START_ELEMENT, &quot;thickness&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			attributes = getAttributes(THICKNESSAttribute.class, e.asStartElement());</b>
&nbsp;
<b class="nc">&nbsp;			checkRequiredAttributes(e, attributes, THICKNESSAttribute.VALUE);</b>
&nbsp;
<b class="nc">&nbsp;			e = getNextEvent();</b>
&nbsp;
<b class="nc">&nbsp;			if (isEvent(e, XMLEvent.START_ELEMENT, &quot;spells&quot;)) {</b>
<b class="nc">&nbsp;				pushback(e);</b>
&nbsp;
<b class="nc">&nbsp;				__spells();</b>
<b class="nc">&nbsp;				e = getNextEvent();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			checkValid(e, XMLEvent.END_ELEMENT, &quot;thickness&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public static interface GEXFConstants {
<b class="nc">&nbsp;		public static enum Balise {</b>
<b class="nc">&nbsp;			GEXF, GRAPH, META, CREATOR, KEYWORDS, DESCRIPTION, NODES, NODE, EDGES, EDGE, COLOR, POSITION, SIZE, SHAPE, THICKNESS, DEFAULT, OPTIONS, ATTVALUES, PARENTS, SPELLS</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum GEXFAttribute {</b>
<b class="nc">&nbsp;			XMLNS, VERSION</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum METAAttribute {</b>
<b class="nc">&nbsp;			LASTMODIFIEDDATE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum GRAPHAttribute {</b>
<b class="nc">&nbsp;			TIMEFORMAT, START, STARTOPEN, END, ENDOPEN, DEFAULTEDGETYPE, IDTYPE, MODE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum ATTRIBUTESAttribute {</b>
<b class="nc">&nbsp;			CLASS, MODE, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum ATTRIBUTEAttribute {</b>
<b class="nc">&nbsp;			ID, TITLE, TYPE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum NODESAttribute {</b>
<b class="nc">&nbsp;			COUNT</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum NODEAttribute {</b>
<b class="nc">&nbsp;			START, STARTOPEN, END, ENDOPEN, PID, ID, LABEL</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum ATTVALUEAttribute {</b>
<b class="nc">&nbsp;			FOR, VALUE, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum PARENTAttribute {</b>
<b class="nc">&nbsp;			FOR</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum EDGESAttribute {</b>
<b class="nc">&nbsp;			COUNT</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum SPELLAttribute {</b>
<b class="nc">&nbsp;			START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum COLORAttribute {</b>
<b class="nc">&nbsp;			R, G, B, A, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum POSITIONAttribute {</b>
<b class="nc">&nbsp;			X, Y, Z, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum SIZEAttribute {</b>
<b class="nc">&nbsp;			VALUE, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum NODESHAPEAttribute {</b>
<b class="nc">&nbsp;			VALUE, URI, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum EDGEAttribute {</b>
<b class="nc">&nbsp;			START, STARTOPEN, END, ENDOPEN, ID, TYPE, LABEL, SOURCE, TARGET, WEIGHT</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum THICKNESSAttribute {</b>
<b class="nc">&nbsp;			VALUE, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum EDGESHAPEAttribute {</b>
<b class="nc">&nbsp;			VALUE, START, STARTOPEN, END, ENDOPEN</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum IDType {</b>
<b class="nc">&nbsp;			INTEGER, STRING</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum ModeType {</b>
<b class="nc">&nbsp;			STATIC, DYNAMIC</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum WeightType {</b>
<b class="nc">&nbsp;			FLOAT</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum EdgeType {</b>
<b class="nc">&nbsp;			DIRECTED, UNDIRECTED, MUTUAL</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum NodeShapeType {</b>
<b class="nc">&nbsp;			DISC, SQUARE, TRIANGLE, DIAMOND, IMAGE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum EdgeShapeType {</b>
<b class="nc">&nbsp;			SOLID, DOTTED, DASHED, DOUBLE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum AttributeType {</b>
<b class="nc">&nbsp;			INTEGER, LONG, FLOAT, DOUBLE, BOOLEAN, ANYURI, LISTSTRING, STRING</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum ClassType {</b>
<b class="nc">&nbsp;			NODE, EDGE</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static enum TimeFormatType {</b>
<b class="nc">&nbsp;			INTEGER, DOUBLE, DATE, DATETIME</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-07-08 16:57</div>
</div>
</body>
</html>
