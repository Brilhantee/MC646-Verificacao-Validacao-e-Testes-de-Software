


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TLPParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.graphstream.stream.file.tlp</a>
</div>

<h1>Coverage Summary for Class: TLPParser (org.graphstream.stream.file.tlp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TLPParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/471)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TLPParser$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TLPParser$Cluster</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TLPParser$JJCalls</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TLPParser$LookaheadSuccess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TLPParser$PropertyType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/481)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
&nbsp; * 
&nbsp; * GraphStream is a library whose purpose is to handle static or dynamic
&nbsp; * graph, create them from scratch, file or any source and display them.
&nbsp; * 
&nbsp; * This program is free software distributed under the terms of two licenses, the
&nbsp; * CeCILL-C license that fits European law, and the GNU Lesser General Public
&nbsp; * License. You can  use, modify and/ or redistribute the software under the terms
&nbsp; * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
&nbsp; * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or (at your
&nbsp; * option) any later version.
&nbsp; * 
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT ANY
&nbsp; * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
&nbsp; * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
&nbsp; * 
&nbsp; * You should have received a copy of the GNU Lesser General Public License
&nbsp; * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; * 
&nbsp; * The fact that you are presently reading this means that you have had
&nbsp; * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * @since 2011-07-21
&nbsp; * 
&nbsp; * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
&nbsp; * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
&nbsp; */
&nbsp;package org.graphstream.stream.file.tlp;
&nbsp;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Reader;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.Stack;
&nbsp;
&nbsp;import org.graphstream.stream.SourceBase.ElementType;
&nbsp;import org.graphstream.stream.file.FileSourceTLP;
&nbsp;import org.graphstream.graph.implementations.AbstractElement.AttributeChangeEvent;
&nbsp;
&nbsp;import org.graphstream.util.parser.ParseException;
&nbsp;import org.graphstream.util.parser.Parser;
&nbsp;import org.graphstream.util.parser.SimpleCharStream;
&nbsp;import org.graphstream.util.parser.Token;
&nbsp;import org.graphstream.util.parser.TokenMgrError;
&nbsp;
&nbsp;/**
&nbsp; * This class defines a TLP parser.
&nbsp; */
&nbsp;@SuppressWarnings(&quot;unused&quot;)
&nbsp;public class TLPParser implements Parser, TLPParserConstants {
&nbsp;
<b class="nc">&nbsp;	protected static enum PropertyType {</b>
<b class="nc">&nbsp;		BOOL, COLOR, DOUBLE, LAYOUT, INT, SIZE, STRING</b>
&nbsp;	}
&nbsp;
&nbsp;	protected static class Cluster {
&nbsp;		int index;
&nbsp;		String name;
&nbsp;
&nbsp;		LinkedList&lt;String&gt; nodes;
&nbsp;		LinkedList&lt;String&gt; edges;
&nbsp;
<b class="nc">&nbsp;		Cluster(int index, String name) {</b>
<b class="nc">&nbsp;			this.index = index;</b>
<b class="nc">&nbsp;			this.name = name;</b>
<b class="nc">&nbsp;			this.nodes = new LinkedList&lt;String&gt;();</b>
<b class="nc">&nbsp;			this.edges = new LinkedList&lt;String&gt;();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The DOT source associated with this parser.
&nbsp;	 */
&nbsp;	private FileSourceTLP tlp;
&nbsp;
&nbsp;	/**
&nbsp;	 * Id of the parser used in events.
&nbsp;	 */
&nbsp;	private String sourceId;
&nbsp;
&nbsp;	private Cluster root;
&nbsp;	private HashMap&lt;Integer, Cluster&gt; clusters;
&nbsp;	private Stack&lt;Cluster&gt; stack;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new parser associated with a TLP source from an input stream.
&nbsp;	 */
&nbsp;	public TLPParser(FileSourceTLP tlp, InputStream stream) {
<b class="nc">&nbsp;		this(stream);</b>
<b class="nc">&nbsp;		init(tlp);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new parser associated with a DOT source from a reader.
&nbsp;	 */
&nbsp;	public TLPParser(FileSourceTLP tlp, Reader stream) {
<b class="nc">&nbsp;		this(stream);</b>
<b class="nc">&nbsp;		init(tlp);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Closes the parser, closing the opened stream.
&nbsp;	 */
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		jj_input_stream.close();</b>
<b class="nc">&nbsp;		clusters.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void init(FileSourceTLP tlp) {
<b class="nc">&nbsp;		this.tlp = tlp;</b>
<b class="nc">&nbsp;		this.sourceId = String.format(&quot;&lt;DOT stream %x&gt;&quot;, System.nanoTime());</b>
&nbsp;
<b class="nc">&nbsp;		this.clusters = new HashMap&lt;Integer, Cluster&gt;();</b>
<b class="nc">&nbsp;		this.stack = new Stack&lt;Cluster&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		this.root = new Cluster(0, &quot;&lt;root&gt;&quot;);</b>
<b class="nc">&nbsp;		this.clusters.put(0, this.root);</b>
<b class="nc">&nbsp;		this.stack.push(this.root);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void addNode(String id) throws ParseException {
<b class="nc">&nbsp;		if (stack.size() &gt; 1 &amp;&amp; (!root.nodes.contains(id) || !stack.get(stack.size() - 2).nodes.contains(id)))</b>
<b class="nc">&nbsp;			throw new ParseException(&quot;parent cluster do not contain the node&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		if (stack.size() == 1)</b>
<b class="nc">&nbsp;			tlp.sendNodeAdded(sourceId, id);</b>
&nbsp;
<b class="nc">&nbsp;		stack.peek().nodes.add(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void addEdge(String id, String source, String target) throws ParseException {
<b class="nc">&nbsp;		if (stack.size() &gt; 1 &amp;&amp; (!root.edges.contains(id) || !stack.get(stack.size() - 2).edges.contains(id)))</b>
<b class="nc">&nbsp;			throw new ParseException(&quot;parent cluster &quot; + stack.get(stack.size() - 2).name + &quot; do not contain the edge&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		if (stack.size() == 1)</b>
<b class="nc">&nbsp;			tlp.sendEdgeAdded(sourceId, id, source, target, false);</b>
&nbsp;
<b class="nc">&nbsp;		stack.peek().edges.add(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void includeEdge(String id) throws ParseException {
<b class="nc">&nbsp;		if (stack.size() &gt; 1 &amp;&amp; (!root.edges.contains(id) || !stack.get(stack.size() - 2).edges.contains(id)))</b>
<b class="nc">&nbsp;			throw new ParseException(&quot;parent cluster &quot; + stack.get(stack.size() - 2).name + &quot; do not contain the edge&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		stack.peek().edges.add(id);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void graphAttribute(String key, Object value) {
<b class="nc">&nbsp;		tlp.sendAttributeChangedEvent(sourceId, sourceId, ElementType.GRAPH, key, AttributeChangeEvent.ADD, null,</b>
&nbsp;				value);
&nbsp;	}
&nbsp;
&nbsp;	private void pushCluster(int i, String name) {
<b class="nc">&nbsp;		Cluster c = new Cluster(i, name);</b>
<b class="nc">&nbsp;		clusters.put(i, c);</b>
<b class="nc">&nbsp;		stack.push(c);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void popCluster() {
<b class="nc">&nbsp;		if (stack.size() &gt; 1)</b>
<b class="nc">&nbsp;			stack.pop();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void newProperty(Integer cluster, String name, PropertyType type, String nodeDefault, String edgeDefault,
&nbsp;			HashMap&lt;String, String&gt; nodes, HashMap&lt;String, String&gt; edges) {
<b class="nc">&nbsp;		Object nodeDefaultValue = convert(type, nodeDefault);</b>
<b class="nc">&nbsp;		Object edgeDefaultValue = convert(type, edgeDefault);</b>
<b class="nc">&nbsp;		Cluster c = clusters.get(cluster);</b>
&nbsp;
<b class="nc">&nbsp;		for (String id : c.nodes) {</b>
<b class="nc">&nbsp;			Object value = nodeDefaultValue;</b>
&nbsp;
<b class="nc">&nbsp;			if (nodes.containsKey(id))</b>
<b class="nc">&nbsp;				value = convert(type, nodes.get(id));</b>
&nbsp;
<b class="nc">&nbsp;			tlp.sendAttributeChangedEvent(sourceId, id, ElementType.NODE, name, AttributeChangeEvent.ADD, null, value);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		for (String id : c.edges) {</b>
<b class="nc">&nbsp;			Object value = edgeDefaultValue;</b>
&nbsp;
<b class="nc">&nbsp;			if (edges.containsKey(id))</b>
<b class="nc">&nbsp;				value = convert(type, edges.get(id));</b>
&nbsp;
<b class="nc">&nbsp;			tlp.sendAttributeChangedEvent(sourceId, id, ElementType.EDGE, name, AttributeChangeEvent.ADD, null, value);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private Object convert(PropertyType type, String value) {
<b class="nc">&nbsp;		switch (type) {</b>
&nbsp;		case BOOL:
<b class="nc">&nbsp;			return Boolean.valueOf(value);</b>
&nbsp;		case INT:
<b class="nc">&nbsp;			return Integer.valueOf(value);</b>
&nbsp;		case DOUBLE:
<b class="nc">&nbsp;			return Double.valueOf(value);</b>
&nbsp;		case LAYOUT:
&nbsp;		case COLOR:
&nbsp;		case SIZE:
&nbsp;		case STRING:
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return value;</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void all() throws ParseException {
<b class="nc">&nbsp;		tlp();</b>
&nbsp;		label_1: while (true) {
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case OBRACKET:
&nbsp;				;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[0] = jj_gen;</b>
<b class="nc">&nbsp;				break label_1;</b>
&nbsp;			}
<b class="nc">&nbsp;			statement();</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(0);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public boolean next() throws ParseException {
<b class="nc">&nbsp;		boolean hasMore = false;</b>
<b class="nc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;		case OBRACKET:
<b class="nc">&nbsp;			statement();</b>
<b class="nc">&nbsp;			hasMore = true;</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case 0:
<b class="nc">&nbsp;			jj_consume_token(0);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[1] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return hasMore;</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void open() throws ParseException {
<b class="nc">&nbsp;		tlp();</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void tlp() throws ParseException {
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(TLP);</b>
<b class="nc">&nbsp;		jj_consume_token(STRING);</b>
&nbsp;		label_2: while (true) {
<b class="nc">&nbsp;			if (jj_2_1(2)) {</b>
&nbsp;				;
&nbsp;			} else {
&nbsp;				break label_2;
&nbsp;			}
<b class="nc">&nbsp;			headers();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final private void headers() throws ParseException {
&nbsp;		String s;
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;		case DATE:
<b class="nc">&nbsp;			jj_consume_token(DATE);</b>
<b class="nc">&nbsp;			s = string();</b>
<b class="nc">&nbsp;			graphAttribute(&quot;date&quot;, s);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case AUTHOR:
<b class="nc">&nbsp;			jj_consume_token(AUTHOR);</b>
<b class="nc">&nbsp;			s = string();</b>
<b class="nc">&nbsp;			graphAttribute(&quot;author&quot;, s);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		case COMMENTS:
<b class="nc">&nbsp;			jj_consume_token(COMMENTS);</b>
<b class="nc">&nbsp;			s = string();</b>
<b class="nc">&nbsp;			graphAttribute(&quot;comments&quot;, s);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[2] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void statement() throws ParseException {
<b class="nc">&nbsp;		if (jj_2_2(2)) {</b>
<b class="nc">&nbsp;			nodes();</b>
<b class="nc">&nbsp;		} else if (jj_2_3(2)) {</b>
<b class="nc">&nbsp;			edge();</b>
<b class="nc">&nbsp;		} else if (jj_2_4(2)) {</b>
<b class="nc">&nbsp;			cluster();</b>
<b class="nc">&nbsp;		} else if (jj_2_5(2)) {</b>
<b class="nc">&nbsp;			property();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final private void nodes() throws ParseException {
&nbsp;		Token i;
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(NODES);</b>
&nbsp;		label_3: while (true) {
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case INTEGER:
&nbsp;				;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[3] = jj_gen;</b>
<b class="nc">&nbsp;				break label_3;</b>
&nbsp;			}
<b class="nc">&nbsp;			i = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;			addNode(i.image);</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void edge() throws ParseException {
&nbsp;		Token i, s, t;
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(EDGE);</b>
<b class="nc">&nbsp;		i = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;		s = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;		t = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
<b class="nc">&nbsp;		addEdge(i.image, s.image, t.image);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void edges() throws ParseException {
&nbsp;		Token i;
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(EDGES);</b>
&nbsp;		label_4: while (true) {
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case INTEGER:
&nbsp;				;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[4] = jj_gen;</b>
<b class="nc">&nbsp;				break label_4;</b>
&nbsp;			}
<b class="nc">&nbsp;			i = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;			includeEdge(i.image);</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void cluster() throws ParseException {
&nbsp;		Token index;
&nbsp;		String name;
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(CLUSTER);</b>
<b class="nc">&nbsp;		index = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;		name = string();</b>
<b class="nc">&nbsp;		pushCluster(Integer.valueOf(index.image), name);</b>
<b class="nc">&nbsp;		nodes();</b>
<b class="nc">&nbsp;		edges();</b>
&nbsp;		label_5: while (true) {
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case OBRACKET:
&nbsp;				;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[5] = jj_gen;</b>
<b class="nc">&nbsp;				break label_5;</b>
&nbsp;			}
<b class="nc">&nbsp;			cluster();</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
<b class="nc">&nbsp;		popCluster();</b>
&nbsp;	}
&nbsp;
&nbsp;	final private void property() throws ParseException {
&nbsp;		PropertyType type;
&nbsp;		Integer cluster;
&nbsp;		String name;
&nbsp;		String nodeDefault, edgeDefault;
&nbsp;		String value;
&nbsp;		Token t;
&nbsp;
<b class="nc">&nbsp;		HashMap&lt;String, String&gt; nodes = new HashMap&lt;String, String&gt;();</b>
<b class="nc">&nbsp;		HashMap&lt;String, String&gt; edges = new HashMap&lt;String, String&gt;();</b>
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(PROPERTY);</b>
<b class="nc">&nbsp;		cluster = integer();</b>
<b class="nc">&nbsp;		type = type();</b>
<b class="nc">&nbsp;		name = string();</b>
<b class="nc">&nbsp;		jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;		jj_consume_token(DEF);</b>
<b class="nc">&nbsp;		nodeDefault = string();</b>
<b class="nc">&nbsp;		edgeDefault = string();</b>
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
&nbsp;		label_6: while (true) {
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case OBRACKET:
&nbsp;				;
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[6] = jj_gen;</b>
<b class="nc">&nbsp;				break label_6;</b>
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(OBRACKET);</b>
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {</b>
&nbsp;			case NODE:
<b class="nc">&nbsp;				jj_consume_token(NODE);</b>
<b class="nc">&nbsp;				t = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;				value = string();</b>
<b class="nc">&nbsp;				nodes.put(t.image, value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case EDGE:
<b class="nc">&nbsp;				jj_consume_token(EDGE);</b>
<b class="nc">&nbsp;				t = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;				value = string();</b>
<b class="nc">&nbsp;				edges.put(t.image, value);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[7] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(CBRACKET);</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_consume_token(CBRACKET);</b>
<b class="nc">&nbsp;		newProperty(cluster, name, type, nodeDefault, edgeDefault, nodes, edges);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private PropertyType type() throws ParseException {
&nbsp;		Token t;
<b class="nc">&nbsp;		t = jj_consume_token(PTYPE);</b>
&nbsp;
<b class="nc">&nbsp;		return PropertyType.valueOf(t.image.toUpperCase());</b>
&nbsp;	}
&nbsp;
&nbsp;	final private String string() throws ParseException {
&nbsp;		Token t;
<b class="nc">&nbsp;		t = jj_consume_token(STRING);</b>
&nbsp;
<b class="nc">&nbsp;		return t.image.substring(1, t.image.length() - 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	final private Integer integer() throws ParseException {
&nbsp;		Token t;
<b class="nc">&nbsp;		t = jj_consume_token(INTEGER);</b>
&nbsp;
<b class="nc">&nbsp;		return Integer.valueOf(t.image);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_1(int xla) {
<b class="nc">&nbsp;		jj_la = xla;</b>
<b class="nc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="nc">&nbsp;			return !jj_3_1();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			jj_save(0, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_2(int xla) {
<b class="nc">&nbsp;		jj_la = xla;</b>
<b class="nc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="nc">&nbsp;			return !jj_3_2();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			jj_save(1, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_3(int xla) {
<b class="nc">&nbsp;		jj_la = xla;</b>
<b class="nc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="nc">&nbsp;			return !jj_3_3();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			jj_save(2, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_4(int xla) {
<b class="nc">&nbsp;		jj_la = xla;</b>
<b class="nc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="nc">&nbsp;			return !jj_3_4();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			jj_save(3, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_5(int xla) {
<b class="nc">&nbsp;		jj_la = xla;</b>
<b class="nc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="nc">&nbsp;			return !jj_3_5();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			jj_save(4, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_1() {
<b class="nc">&nbsp;		if (jj_3R_7())</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_5() {
<b class="nc">&nbsp;		if (jj_3R_11())</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_9() {
<b class="nc">&nbsp;		if (jj_scan_token(OBRACKET))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		if (jj_scan_token(EDGE))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_4() {
<b class="nc">&nbsp;		if (jj_3R_10())</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_3() {
<b class="nc">&nbsp;		if (jj_3R_9())</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_14() {
<b class="nc">&nbsp;		if (jj_scan_token(COMMENTS))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_13() {
<b class="nc">&nbsp;		if (jj_scan_token(AUTHOR))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_2() {
<b class="nc">&nbsp;		if (jj_3R_8())</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_12() {
<b class="nc">&nbsp;		if (jj_scan_token(DATE))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_11() {
<b class="nc">&nbsp;		if (jj_scan_token(OBRACKET))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		if (jj_scan_token(PROPERTY))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_10() {
<b class="nc">&nbsp;		if (jj_scan_token(OBRACKET))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		if (jj_scan_token(CLUSTER))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_7() {
<b class="nc">&nbsp;		if (jj_scan_token(OBRACKET))</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		Token xsp;
<b class="nc">&nbsp;		xsp = jj_scanpos;</b>
<b class="nc">&nbsp;		if (jj_3R_12()) {</b>
<b class="nc">&nbsp;			jj_scanpos = xsp;</b>
<b class="nc">&nbsp;			if (jj_3R_13()) {</b>
<b class="nc">&nbsp;				jj_scanpos = xsp;</b>
<b class="nc">&nbsp;				if (jj_3R_14())</b>
<b class="nc">&nbsp;					return true;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_8() {
<b class="nc">&nbsp;		if (jj_scan_token(OBRACKET))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		if (jj_scan_token(NODES))</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Generated Token Manager. */
&nbsp;	public TLPParserTokenManager token_source;
&nbsp;	SimpleCharStream jj_input_stream;
&nbsp;	/** Current token. */
&nbsp;	public Token token;
&nbsp;	/** Next token. */
&nbsp;	public Token jj_nt;
&nbsp;	private int jj_ntk;
&nbsp;	private Token jj_scanpos, jj_lastpos;
&nbsp;	private int jj_la;
&nbsp;	private int jj_gen;
<b class="nc">&nbsp;	final private int[] jj_la1 = new int[8];</b>
&nbsp;	static private int[] jj_la1_0;
&nbsp;	static {
<b class="nc">&nbsp;		jj_la1_init_0();</b>
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_0() {
<b class="nc">&nbsp;		jj_la1_0 = new int[] { 0x400, 0x401, 0x380000, 0x1000000, 0x1000000, 0x400, 0x400, 0x14000, };</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	final private JJCalls[] jj_2_rtns = new JJCalls[5];</b>
<b class="nc">&nbsp;	private boolean jj_rescan = false;</b>
<b class="nc">&nbsp;	private int jj_gc = 0;</b>
&nbsp;
&nbsp;	/** Constructor with InputStream. */
&nbsp;	public TLPParser(java.io.InputStream stream) {
<b class="nc">&nbsp;		this(stream, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Constructor with InputStream and supplied encoding */
<b class="nc">&nbsp;	public TLPParser(java.io.InputStream stream, String encoding) {</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);</b>
<b class="nc">&nbsp;		} catch (java.io.UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;			throw new RuntimeException(e);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		token_source = new TLPParserTokenManager(jj_input_stream);</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Reinitialise. */
&nbsp;	public void ReInit(java.io.InputStream stream) {
<b class="nc">&nbsp;		ReInit(stream, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Reinitialise. */
&nbsp;	public void ReInit(java.io.InputStream stream, String encoding) {
&nbsp;		try {
<b class="nc">&nbsp;			jj_input_stream.ReInit(stream, encoding, 1, 1);</b>
<b class="nc">&nbsp;		} catch (java.io.UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;			throw new RuntimeException(e);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		token_source.ReInit(jj_input_stream);</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Constructor. */
<b class="nc">&nbsp;	public TLPParser(java.io.Reader stream) {</b>
<b class="nc">&nbsp;		jj_input_stream = new SimpleCharStream(stream, 1, 1);</b>
<b class="nc">&nbsp;		token_source = new TLPParserTokenManager(jj_input_stream);</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Reinitialise. */
&nbsp;	public void ReInit(java.io.Reader stream) {
<b class="nc">&nbsp;		jj_input_stream.ReInit(stream, 1, 1);</b>
<b class="nc">&nbsp;		token_source.ReInit(jj_input_stream);</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Constructor with generated Token Manager. */
<b class="nc">&nbsp;	public TLPParser(TLPParserTokenManager tm) {</b>
<b class="nc">&nbsp;		token_source = tm;</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Reinitialise. */
&nbsp;	public void ReInit(TLPParserTokenManager tm) {
<b class="nc">&nbsp;		token_source = tm;</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++)</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++)</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;	}
&nbsp;
&nbsp;	private Token jj_consume_token(int kind) throws ParseException {
&nbsp;		Token oldToken;
<b class="nc">&nbsp;		if ((oldToken = token).next != null)</b>
<b class="nc">&nbsp;			token = token.next;</b>
&nbsp;		else
<b class="nc">&nbsp;			token = token.next = token_source.getNextToken();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		if (token.kind == kind) {</b>
<b class="nc">&nbsp;			jj_gen++;</b>
<b class="nc">&nbsp;			if (++jj_gc &gt; 100) {</b>
<b class="nc">&nbsp;				jj_gc = 0;</b>
<b class="nc">&nbsp;				for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="nc">&nbsp;					JJCalls c = jj_2_rtns[i];</b>
<b class="nc">&nbsp;					while (c != null) {</b>
<b class="nc">&nbsp;						if (c.gen &lt; jj_gen)</b>
<b class="nc">&nbsp;							c.first = null;</b>
<b class="nc">&nbsp;						c = c.next;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return token;</b>
&nbsp;		}
<b class="nc">&nbsp;		token = oldToken;</b>
<b class="nc">&nbsp;		jj_kind = kind;</b>
<b class="nc">&nbsp;		throw generateParseException();</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static private final class LookaheadSuccess extends java.lang.Error {</b>
&nbsp;		private static final long serialVersionUID = -7986896058452164869L;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	final private LookaheadSuccess jj_ls = new LookaheadSuccess();</b>
&nbsp;
&nbsp;	private boolean jj_scan_token(int kind) {
<b class="nc">&nbsp;		if (jj_scanpos == jj_lastpos) {</b>
<b class="nc">&nbsp;			jj_la--;</b>
<b class="nc">&nbsp;			if (jj_scanpos.next == null) {</b>
<b class="nc">&nbsp;				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jj_lastpos = jj_scanpos = jj_scanpos.next;</b>
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			jj_scanpos = jj_scanpos.next;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (jj_rescan) {</b>
<b class="nc">&nbsp;			int i = 0;</b>
<b class="nc">&nbsp;			Token tok = token;</b>
<b class="nc">&nbsp;			while (tok != null &amp;&amp; tok != jj_scanpos) {</b>
<b class="nc">&nbsp;				i++;</b>
<b class="nc">&nbsp;				tok = tok.next;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (tok != null)</b>
<b class="nc">&nbsp;				jj_add_error_token(kind, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (jj_scanpos.kind != kind)</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos)</b>
<b class="nc">&nbsp;			throw jj_ls;</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Get the next Token. */
&nbsp;	final public Token getNextToken() {
<b class="nc">&nbsp;		if (token.next != null)</b>
<b class="nc">&nbsp;			token = token.next;</b>
&nbsp;		else
<b class="nc">&nbsp;			token = token.next = token_source.getNextToken();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen++;</b>
<b class="nc">&nbsp;		return token;</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Get the specific Token. */
&nbsp;	final public Token getToken(int index) {
<b class="nc">&nbsp;		Token t = token;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; index; i++) {</b>
<b class="nc">&nbsp;			if (t.next != null)</b>
<b class="nc">&nbsp;				t = t.next;</b>
&nbsp;			else
<b class="nc">&nbsp;				t = t.next = token_source.getNextToken();</b>
&nbsp;		}
<b class="nc">&nbsp;		return t;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int jj_ntk() {
<b class="nc">&nbsp;		if ((jj_nt = token.next) == null)</b>
<b class="nc">&nbsp;			return (jj_ntk = (token.next = token_source.getNextToken()).kind);</b>
&nbsp;		else
<b class="nc">&nbsp;			return (jj_ntk = jj_nt.kind);</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;int[]&gt;();</b>
&nbsp;	private int[] jj_expentry;
<b class="nc">&nbsp;	private int jj_kind = -1;</b>
<b class="nc">&nbsp;	private int[] jj_lasttokens = new int[100];</b>
&nbsp;	private int jj_endpos;
&nbsp;
&nbsp;	private void jj_add_error_token(int kind, int pos) {
<b class="nc">&nbsp;		if (pos &gt;= 100)</b>
&nbsp;			return;
<b class="nc">&nbsp;		if (pos == jj_endpos + 1) {</b>
<b class="nc">&nbsp;			jj_lasttokens[jj_endpos++] = kind;</b>
<b class="nc">&nbsp;		} else if (jj_endpos != 0) {</b>
<b class="nc">&nbsp;			jj_expentry = new int[jj_endpos];</b>
<b class="nc">&nbsp;			for (int i = 0; i &lt; jj_endpos; i++) {</b>
<b class="nc">&nbsp;				jj_expentry[i] = jj_lasttokens[i];</b>
&nbsp;			}
<b class="nc">&nbsp;			jj_entries_loop: for (java.util.Iterator&lt;?&gt; it = jj_expentries.iterator(); it.hasNext();) {</b>
<b class="nc">&nbsp;				int[] oldentry = (int[]) (it.next());</b>
<b class="nc">&nbsp;				if (oldentry.length == jj_expentry.length) {</b>
<b class="nc">&nbsp;					for (int i = 0; i &lt; jj_expentry.length; i++) {</b>
<b class="nc">&nbsp;						if (oldentry[i] != jj_expentry[i]) {</b>
<b class="nc">&nbsp;							continue jj_entries_loop;</b>
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					jj_expentries.add(jj_expentry);</b>
<b class="nc">&nbsp;					break jj_entries_loop;</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			if (pos != 0)</b>
<b class="nc">&nbsp;				jj_lasttokens[(jj_endpos = pos) - 1] = kind;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/** Generate ParseException. */
&nbsp;	public ParseException generateParseException() {
<b class="nc">&nbsp;		jj_expentries.clear();</b>
<b class="nc">&nbsp;		boolean[] la1tokens = new boolean[28];</b>
<b class="nc">&nbsp;		if (jj_kind &gt;= 0) {</b>
<b class="nc">&nbsp;			la1tokens[jj_kind] = true;</b>
<b class="nc">&nbsp;			jj_kind = -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; 8; i++) {</b>
<b class="nc">&nbsp;			if (jj_la1[i] == jj_gen) {</b>
<b class="nc">&nbsp;				for (int j = 0; j &lt; 32; j++) {</b>
<b class="nc">&nbsp;					if ((jj_la1_0[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[j] = true;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; 28; i++) {</b>
<b class="nc">&nbsp;			if (la1tokens[i]) {</b>
<b class="nc">&nbsp;				jj_expentry = new int[1];</b>
<b class="nc">&nbsp;				jj_expentry[0] = i;</b>
<b class="nc">&nbsp;				jj_expentries.add(jj_expentry);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		jj_endpos = 0;</b>
<b class="nc">&nbsp;		jj_rescan_token();</b>
<b class="nc">&nbsp;		jj_add_error_token(0, 0);</b>
<b class="nc">&nbsp;		int[][] exptokseq = new int[jj_expentries.size()][];</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_expentries.size(); i++) {</b>
<b class="nc">&nbsp;			exptokseq[i] = jj_expentries.get(i);</b>
&nbsp;		}
<b class="nc">&nbsp;		return new ParseException(token, exptokseq, tokenImage);</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Enable tracing. */
&nbsp;	final public void enable_tracing() {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	/** Disable tracing. */
&nbsp;	final public void disable_tracing() {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private void jj_rescan_token() {
<b class="nc">&nbsp;		jj_rescan = true;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 5; i++) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				JJCalls p = jj_2_rtns[i];</b>
&nbsp;				do {
<b class="nc">&nbsp;					if (p.gen &gt; jj_gen) {</b>
<b class="nc">&nbsp;						jj_la = p.arg;</b>
<b class="nc">&nbsp;						jj_lastpos = jj_scanpos = p.first;</b>
<b class="nc">&nbsp;						switch (i) {</b>
&nbsp;						case 0:
<b class="nc">&nbsp;							jj_3_1();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 1:
<b class="nc">&nbsp;							jj_3_2();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 2:
<b class="nc">&nbsp;							jj_3_3();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 3:
<b class="nc">&nbsp;							jj_3_4();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 4:
<b class="nc">&nbsp;							jj_3_5();</b>
&nbsp;							break;
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					p = p.next;</b>
<b class="nc">&nbsp;				} while (p != null);</b>
<b class="nc">&nbsp;			} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_rescan = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void jj_save(int index, int xla) {
<b class="nc">&nbsp;		JJCalls p = jj_2_rtns[index];</b>
<b class="nc">&nbsp;		while (p.gen &gt; jj_gen) {</b>
<b class="nc">&nbsp;			if (p.next == null) {</b>
<b class="nc">&nbsp;				p = p.next = new JJCalls();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
<b class="nc">&nbsp;			p = p.next;</b>
&nbsp;		}
<b class="nc">&nbsp;		p.gen = jj_gen + xla - jj_la;</b>
<b class="nc">&nbsp;		p.first = token;</b>
<b class="nc">&nbsp;		p.arg = xla;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static final class JJCalls {</b>
&nbsp;		int gen;
&nbsp;		Token first;
&nbsp;		int arg;
&nbsp;		JJCalls next;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-07-08 16:57</div>
</div>
</body>
</html>
