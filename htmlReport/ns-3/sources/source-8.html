


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Graphs</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.graphstream.graph.implementations</a>
</div>

<h1>Coverage Summary for Class: Graphs (org.graphstream.graph.implementations)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Graphs</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Graphs$SynchronizedEdge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Graphs$SynchronizedElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/114)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Graphs$SynchronizedGraph</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/276)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Graphs$SynchronizedNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/130)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/139)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/613)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
&nbsp; * 
&nbsp; * GraphStream is a library whose purpose is to handle static or dynamic
&nbsp; * graph, create them from scratch, file or any source and display them.
&nbsp; * 
&nbsp; * This program is free software distributed under the terms of two licenses, the
&nbsp; * CeCILL-C license that fits European law, and the GNU Lesser General Public
&nbsp; * License. You can  use, modify and/ or redistribute the software under the terms
&nbsp; * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
&nbsp; * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or (at your
&nbsp; * option) any later version.
&nbsp; * 
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT ANY
&nbsp; * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
&nbsp; * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
&nbsp; * 
&nbsp; * You should have received a copy of the GNU Lesser General Public License
&nbsp; * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; * 
&nbsp; * The fact that you are presently reading this means that you have had
&nbsp; * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * @since 2011-08-23
&nbsp; * 
&nbsp; * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
&nbsp; * @author Stefan Balev &lt;stefan.balev@graphstream-project.org&gt;
&nbsp; * @author Alex Bowen &lt;bowen.a@gmail.com&gt;
&nbsp; * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
&nbsp; * @author Yoann Pign√© &lt;yoann.pigne@graphstream-project.org&gt;
&nbsp; */
&nbsp;package org.graphstream.graph.implementations;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Spliterator;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.graphstream.graph.Edge;
&nbsp;import org.graphstream.graph.EdgeFactory;
&nbsp;import org.graphstream.graph.EdgeRejectedException;
&nbsp;import org.graphstream.graph.Element;
&nbsp;import org.graphstream.graph.ElementNotFoundException;
&nbsp;import org.graphstream.graph.Graph;
&nbsp;import org.graphstream.graph.IdAlreadyInUseException;
&nbsp;import org.graphstream.graph.Node;
&nbsp;import org.graphstream.graph.NodeFactory;
&nbsp;import org.graphstream.stream.AttributeSink;
&nbsp;import org.graphstream.stream.ElementSink;
&nbsp;import org.graphstream.stream.GraphParseException;
&nbsp;import org.graphstream.stream.GraphReplay;
&nbsp;import org.graphstream.stream.Sink;
&nbsp;import org.graphstream.stream.file.FileSink;
&nbsp;import org.graphstream.stream.file.FileSource;
&nbsp;import org.graphstream.ui.view.Viewer;
&nbsp;
<b class="nc">&nbsp;public class Graphs {</b>
&nbsp;
<b class="nc">&nbsp;	private static final Logger logger = Logger.getLogger(Graphs.class.getSimpleName());</b>
&nbsp;
&nbsp;	public static Graph unmutableGraph(Graph g) {
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Synchronizes a graph. The returned graph can be accessed and modified by
&nbsp;	 * several threads. You lose genericity in methods returning edge or node
&nbsp;	 * because each element (graph, nodes and edges) is wrapped into a synchronized
&nbsp;	 * wrapper which breaks original elements class.
&nbsp;	 *
&nbsp;	 * @param g
&nbsp;	 *            the graph to synchronize
&nbsp;	 * @return a synchronized wrapper for g
&nbsp;	 */
&nbsp;	public static Graph synchronizedGraph(Graph g) {
<b class="nc">&nbsp;		return new SynchronizedGraph(g);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Merge several graphs in one. A new graph is created, that will contain the
&nbsp;	 * result. The method will try to create a graph of the same class that the
&nbsp;	 * first graph to merge (it needs to have a constructor with a String). Else, a
&nbsp;	 * MultiGraph is used.
&nbsp;	 *
&nbsp;	 * @param graphs
&nbsp;	 *            graphs to merge
&nbsp;	 * @return merge result
&nbsp;	 */
&nbsp;	public static Graph merge(Graph... graphs) {
<b class="nc">&nbsp;		if (graphs == null)</b>
<b class="nc">&nbsp;			return new DefaultGraph(&quot;void-merge&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		String id = &quot;merge&quot;;</b>
&nbsp;
<b class="nc">&nbsp;		for (Graph g : graphs)</b>
<b class="nc">&nbsp;			id += &quot;-&quot; + g.getId();</b>
&nbsp;
&nbsp;		Graph result;
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			Class&lt;? extends Graph&gt; cls = graphs[0].getClass();</b>
<b class="nc">&nbsp;			result = cls.getConstructor(String.class).newInstance(id);</b>
<b class="nc">&nbsp;		} catch (Exception e) {</b>
<b class="nc">&nbsp;			logger.warning(String.format(&quot;Cannot create a graph of %s.&quot;, graphs[0].getClass().getName()));</b>
<b class="nc">&nbsp;			result = new MultiGraph(id);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		mergeIn(result, graphs);</b>
&nbsp;
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Merge several graphs in one. The first parameter is the graph in which the
&nbsp;	 * other graphs will be merged.
&nbsp;	 *
&nbsp;	 * @param result
&nbsp;	 *            destination graph.
&nbsp;	 * @param graphs
&nbsp;	 *            all graphs that will be merged in result.
&nbsp;	 */
&nbsp;	public static void mergeIn(Graph result, Graph... graphs) {
<b class="nc">&nbsp;		boolean strict = result.isStrict();</b>
<b class="nc">&nbsp;		GraphReplay replay = new GraphReplay(String.format(&quot;replay-%x&quot;, System.nanoTime()));</b>
&nbsp;
<b class="nc">&nbsp;		replay.addSink(result);</b>
<b class="nc">&nbsp;		result.setStrict(false);</b>
&nbsp;
<b class="nc">&nbsp;		if (graphs != null)</b>
<b class="nc">&nbsp;			for (Graph g : graphs)</b>
<b class="nc">&nbsp;				replay.replay(g);</b>
&nbsp;
<b class="nc">&nbsp;		replay.removeSink(result);</b>
<b class="nc">&nbsp;		result.setStrict(strict);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Clone a given graph with same node/edge structure and same attributes.
&nbsp;	 *
&nbsp;	 * @param g
&nbsp;	 *            the graph to clone
&nbsp;	 * @return a copy of g
&nbsp;	 */
&nbsp;	public static Graph clone(Graph g) {
&nbsp;		Graph copy;
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			Class&lt;? extends Graph&gt; cls = g.getClass();</b>
<b class="nc">&nbsp;			copy = cls.getConstructor(String.class).newInstance(g.getId());</b>
<b class="nc">&nbsp;		} catch (Exception e) {</b>
<b class="nc">&nbsp;			logger.warning(String.format(&quot;Cannot create a graph of %s.&quot;, g.getClass().getName()));</b>
<b class="nc">&nbsp;			copy = new AdjacencyListGraph(g.getId());</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		copyAttributes(g, copy);</b>
&nbsp;
<b class="nc">&nbsp;		for (int i = 0; i &lt; g.getNodeCount(); i++) {</b>
<b class="nc">&nbsp;			Node source = g.getNode(i);</b>
<b class="nc">&nbsp;			Node target = copy.addNode(source.getId());</b>
&nbsp;
<b class="nc">&nbsp;			copyAttributes(source, target);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		for (int i = 0; i &lt; g.getEdgeCount(); i++) {</b>
<b class="nc">&nbsp;			Edge source = g.getEdge(i);</b>
<b class="nc">&nbsp;			Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(),</b>
<b class="nc">&nbsp;					source.isDirected());</b>
&nbsp;
<b class="nc">&nbsp;			copyAttributes(source, target);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return copy;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param source
&nbsp;	 * @param target
&nbsp;	 */
&nbsp;	public static void copyAttributes(Element source, Element target) {
<b class="nc">&nbsp;		source.attributeKeys().forEach(key -&gt; {</b>
<b class="nc">&nbsp;			Object value = source.getAttribute(key);</b>
<b class="nc">&nbsp;			value = checkedArrayOrCollectionCopy(value);</b>
&nbsp;
<b class="nc">&nbsp;			target.setAttribute(key, value);</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;	private static Object checkedArrayOrCollectionCopy(Object o) {
<b class="nc">&nbsp;		if (o == null)</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;
<b class="nc">&nbsp;		if (o.getClass().isArray()) {</b>
&nbsp;
<b class="nc">&nbsp;			Object c = Array.newInstance(o.getClass().getComponentType(), Array.getLength(o));</b>
&nbsp;
<b class="nc">&nbsp;			for (int i = 0; i &lt; Array.getLength(o); i++) {</b>
<b class="nc">&nbsp;				Object t = checkedArrayOrCollectionCopy(Array.get(o, i));</b>
<b class="nc">&nbsp;				Array.set(c, i, t);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return c;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (Collection.class.isAssignableFrom(o.getClass())) {</b>
&nbsp;			Collection&lt;?&gt; t;
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				t = (Collection&lt;?&gt;) o.getClass().newInstance();</b>
<b class="nc">&nbsp;				t.addAll((Collection) o);</b>
&nbsp;
<b class="nc">&nbsp;				return t;</b>
<b class="nc">&nbsp;			} catch (Exception e) {</b>
<b class="nc">&nbsp;				e.printStackTrace();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return o;</b>
&nbsp;	}
&nbsp;
&nbsp;	static class SynchronizedElement&lt;U extends Element&gt; implements Element {
&nbsp;
<b class="nc">&nbsp;		private static final ReentrantLock attributeLock = new ReentrantLock();  // Static to lock the attributes from different sources (graph/node/edge). Fix issue #293</b>
&nbsp;		protected final U wrappedElement;
&nbsp;
<b class="nc">&nbsp;		SynchronizedElement(U e) {</b>
<b class="nc">&nbsp;			this.wrappedElement = e;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAttribute(String attribute, Object... values) {
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setAttribute(attribute, values);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAttributes(Map&lt;String, Object&gt; attributes) {
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setAttributes(attributes);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		public void clearAttributes() {
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.clearAttributes();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		public Object[] getArray(String key) {
&nbsp;			Object[] o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getArray(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Object getAttribute(String key) {
&nbsp;			Object o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getAttribute(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public &lt;T&gt; T getAttribute(String key, Class&lt;T&gt; clazz) {
&nbsp;			T o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getAttribute(key, clazz);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public int getAttributeCount() {
&nbsp;			int c;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				c = wrappedElement.getAttributeCount();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return c;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;String&gt; attributeKeys() {
<b class="nc">&nbsp;			Stream&lt;String&gt; s = null;</b>
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				s = wrappedElement.attributeKeys();</b>
&nbsp;
<b class="nc">&nbsp;				if (!s.spliterator().hasCharacteristics(Spliterator.CONCURRENT))</b>
<b class="nc">&nbsp;					s = s.collect(Collectors.toList()).stream();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return s;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Object getFirstAttributeOf(String... keys) {
&nbsp;			Object o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getFirstAttributeOf(keys);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public &lt;T&gt; T getFirstAttributeOf(Class&lt;T&gt; clazz, String... keys) {
&nbsp;			T o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getFirstAttributeOf(clazz, keys);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;?, ?&gt; getMap(String key) {
&nbsp;			Map&lt;?, ?&gt; o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getMap(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getId() {
<b class="nc">&nbsp;			return wrappedElement.getId();</b>
&nbsp;		}
&nbsp;
&nbsp;		public int getIndex() {
<b class="nc">&nbsp;			return wrappedElement.getIndex();</b>
&nbsp;		}
&nbsp;
&nbsp;		public CharSequence getLabel(String key) {
&nbsp;			CharSequence o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getLabel(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public double getNumber(String key) {
&nbsp;			double o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getNumber(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public List&lt;? extends Number&gt; getVector(String key) {
&nbsp;			List&lt;? extends Number&gt; o;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				o = wrappedElement.getVector(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return o;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasArray(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasArray(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasAttribute(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasAttribute(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasAttribute(String key, Class&lt;?&gt; clazz) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasAttribute(key, clazz);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasMap(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasMap(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasLabel(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasLabel(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasNumber(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasNumber(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean hasVector(String key) {
&nbsp;			boolean b;
&nbsp;
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				b = wrappedElement.hasVector(key);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return b;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void removeAttribute(String attribute) {
<b class="nc">&nbsp;			attributeLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.removeAttribute(attribute);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				attributeLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class SynchronizedGraph extends SynchronizedElement&lt;Graph&gt; implements Graph {
&nbsp;
&nbsp;		final ReentrantLock elementLock;
&nbsp;		final Map&lt;String, Node&gt; synchronizedNodes;
&nbsp;		final Map&lt;String, Edge&gt; synchronizedEdges;
&nbsp;
&nbsp;		SynchronizedGraph(Graph g) {
<b class="nc">&nbsp;			super(g);</b>
&nbsp;
<b class="nc">&nbsp;			elementLock = new ReentrantLock();</b>
&nbsp;
<b class="nc">&nbsp;			synchronizedNodes = g.nodes().collect(Collectors.toMap(Node::getId, n -&gt; new SynchronizedNode(this, n)));</b>
<b class="nc">&nbsp;			synchronizedEdges = g.edges().collect(Collectors.toMap(Edge::getId, e -&gt; new SynchronizedEdge(this, e)));</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Node&gt; nodes() {
&nbsp;			Collection&lt;Node&gt; nodes;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				nodes = new Vector&lt;&gt;(synchronizedNodes.values());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return nodes.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Edge&gt; edges() {
&nbsp;			Collection&lt;Edge&gt; edges;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				edges = new Vector&lt;&gt;(synchronizedEdges.values());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return edges.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, String node1, String node2)
&nbsp;				throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, node1, node2);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, String from, String to, boolean directed)
&nbsp;				throws IdAlreadyInUseException, ElementNotFoundException {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, from, to, directed);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, int index1, int index2) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, index1, index2);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, int fromIndex, int toIndex, boolean directed) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, fromIndex, toIndex, directed);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, Node node1, Node node2) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;			final Node unsyncNode1, unsyncNode2;
&nbsp;
<b class="nc">&nbsp;			unsyncNode1 = ((SynchronizedElement&lt;Node&gt;) node1).wrappedElement;</b>
<b class="nc">&nbsp;			unsyncNode2 = ((SynchronizedElement&lt;Node&gt;) node2).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, unsyncNode1, unsyncNode2);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		@Override
&nbsp;		public Edge addEdge(String id, Node from, Node to, boolean directed) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;			final Node unsyncFrom, unsyncTo;
&nbsp;
<b class="nc">&nbsp;			unsyncFrom = ((SynchronizedElement&lt;Node&gt;) from).wrappedElement;</b>
<b class="nc">&nbsp;			unsyncTo = ((SynchronizedElement&lt;Node&gt;) to).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.addEdge(id, unsyncFrom, unsyncTo, directed);</b>
<b class="nc">&nbsp;				se = new SynchronizedEdge(this, e);</b>
<b class="nc">&nbsp;				synchronizedEdges.put(id, se);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node addNode(String id) throws IdAlreadyInUseException {
&nbsp;			Node n;
&nbsp;			Node sn;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = wrappedElement.addNode(id);</b>
<b class="nc">&nbsp;				sn = new SynchronizedNode(this, n);</b>
<b class="nc">&nbsp;				synchronizedNodes.put(id, sn);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sn;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterable&lt;AttributeSink&gt; attributeSinks() {
<b class="nc">&nbsp;			LinkedList&lt;AttributeSink&gt; sinks = new LinkedList&lt;AttributeSink&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				for (AttributeSink as : wrappedElement.attributeSinks())</b>
<b class="nc">&nbsp;					sinks.add(as);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sinks;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void clear() {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.clear();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public EdgeFactory&lt;? extends Edge&gt; edgeFactory() {
<b class="nc">&nbsp;			return wrappedElement.edgeFactory();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterable&lt;ElementSink&gt; elementSinks() {
<b class="nc">&nbsp;			LinkedList&lt;ElementSink&gt; sinks = new LinkedList&lt;ElementSink&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				for (ElementSink es : wrappedElement.elementSinks())</b>
<b class="nc">&nbsp;					sinks.add(es);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sinks;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdge(String id) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = synchronizedEdges.get(id);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdge(int index) throws IndexOutOfBoundsException {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.getEdge(index);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e == null ? null : getEdge(e.getId());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getEdgeCount() {
&nbsp;			int c;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				c = synchronizedEdges.size();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return c;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getNode(String id) {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = synchronizedNodes.get(id);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getNode(int index) throws IndexOutOfBoundsException {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = wrappedElement.getNode(index);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n == null ? null : getNode(n.getId());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getNodeCount() {
&nbsp;			int c;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				c = synchronizedNodes.size();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return c;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double getStep() {
&nbsp;			double s;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				s = wrappedElement.getStep();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return s;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isAutoCreationEnabled() {
<b class="nc">&nbsp;			return wrappedElement.isAutoCreationEnabled();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Viewer display() {
<b class="nc">&nbsp;			return wrappedElement.display();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Viewer display(boolean autoLayout) {
<b class="nc">&nbsp;			return wrappedElement.display(autoLayout);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isStrict() {
<b class="nc">&nbsp;			return wrappedElement.isStrict();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public NodeFactory&lt;? extends Node&gt; nodeFactory() {
<b class="nc">&nbsp;			return wrappedElement.nodeFactory();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void read(String filename) throws IOException, GraphParseException, ElementNotFoundException {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.read(filename);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void read(FileSource input, String filename) throws IOException, GraphParseException {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.read(input, filename);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(String from, String to) throws ElementNotFoundException {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(from, to);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(String id) throws ElementNotFoundException {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(id);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(int index) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(index);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(int fromIndex, int toIndex) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(fromIndex, toIndex);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(Node node1, Node node2) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			if (node1 instanceof SynchronizedNode)</b>
<b class="nc">&nbsp;				node1 = ((SynchronizedNode) node1).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			if (node2 instanceof SynchronizedNode)</b>
<b class="nc">&nbsp;				node2 = ((SynchronizedNode) node1).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(node1, node2);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge removeEdge(Edge edge) {
&nbsp;			Edge e;
&nbsp;			Edge se;
&nbsp;
<b class="nc">&nbsp;			if (edge instanceof SynchronizedEdge)</b>
<b class="nc">&nbsp;				edge = ((SynchronizedEdge) edge).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = wrappedElement.removeEdge(edge);</b>
<b class="nc">&nbsp;				se = synchronizedEdges.remove(e.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return se;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node removeNode(String id) throws ElementNotFoundException {
&nbsp;			Node n;
&nbsp;			Node sn;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = wrappedElement.removeNode(id);</b>
<b class="nc">&nbsp;				sn = synchronizedNodes.remove(n.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sn;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node removeNode(int index) {
&nbsp;			Node n;
&nbsp;			Node sn;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = wrappedElement.removeNode(index);</b>
<b class="nc">&nbsp;				sn = synchronizedNodes.remove(n.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sn;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node removeNode(Node node) {
&nbsp;			Node n;
&nbsp;			Node sn;
&nbsp;
<b class="nc">&nbsp;			if (node instanceof SynchronizedNode)</b>
<b class="nc">&nbsp;				node = ((SynchronizedNode) node).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = wrappedElement.removeNode(node);</b>
<b class="nc">&nbsp;				sn = synchronizedNodes.remove(n.getId());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return sn;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setAutoCreate(boolean on) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setAutoCreate(on);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setEdgeFactory(EdgeFactory&lt;? extends Edge&gt; ef) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setEdgeFactory(ef);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setNodeFactory(NodeFactory&lt;? extends Node&gt; nf) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setNodeFactory(nf);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setStrict(boolean on) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.setStrict(on);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void stepBegins(double time) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.stepBegins(time);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void write(String filename) throws IOException {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.write(filename);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void write(FileSink output, String filename) throws IOException {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.write(output, filename);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void addAttributeSink(AttributeSink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.addAttributeSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void addElementSink(ElementSink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.addElementSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void addSink(Sink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.addSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void clearAttributeSinks() {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.clearAttributeSinks();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void clearElementSinks() {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.clearElementSinks();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void clearSinks() {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.clearSinks();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void removeAttributeSink(AttributeSink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.removeAttributeSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void removeElementSink(ElementSink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.removeElementSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void removeSink(Sink sink) {
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				wrappedElement.removeSink(sink);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void edgeAttributeAdded(String sourceId, long timeId, String edgeId, String attribute, Object value) {
<b class="nc">&nbsp;			wrappedElement.edgeAttributeAdded(sourceId, timeId, edgeId, attribute, value);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void edgeAttributeChanged(String sourceId, long timeId, String edgeId, String attribute, Object oldValue,
&nbsp;				Object newValue) {
<b class="nc">&nbsp;			wrappedElement.edgeAttributeChanged(sourceId, timeId, edgeId, attribute, oldValue, newValue);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void edgeAttributeRemoved(String sourceId, long timeId, String edgeId, String attribute) {
<b class="nc">&nbsp;			wrappedElement.edgeAttributeRemoved(sourceId, timeId, edgeId, attribute);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void graphAttributeAdded(String sourceId, long timeId, String attribute, Object value) {
<b class="nc">&nbsp;			wrappedElement.graphAttributeAdded(sourceId, timeId, attribute, value);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void graphAttributeChanged(String sourceId, long timeId, String attribute, Object oldValue,
&nbsp;				Object newValue) {
<b class="nc">&nbsp;			wrappedElement.graphAttributeChanged(sourceId, timeId, attribute, oldValue, newValue);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void graphAttributeRemoved(String sourceId, long timeId, String attribute) {
<b class="nc">&nbsp;			wrappedElement.graphAttributeRemoved(sourceId, timeId, attribute);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void nodeAttributeAdded(String sourceId, long timeId, String nodeId, String attribute, Object value) {
<b class="nc">&nbsp;			wrappedElement.nodeAttributeAdded(sourceId, timeId, nodeId, attribute, value);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void nodeAttributeChanged(String sourceId, long timeId, String nodeId, String attribute, Object oldValue,
&nbsp;				Object newValue) {
<b class="nc">&nbsp;			wrappedElement.nodeAttributeChanged(sourceId, timeId, nodeId, attribute, oldValue, newValue);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void nodeAttributeRemoved(String sourceId, long timeId, String nodeId, String attribute) {
<b class="nc">&nbsp;			wrappedElement.nodeAttributeRemoved(sourceId, timeId, nodeId, attribute);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void edgeAdded(String sourceId, long timeId, String edgeId, String fromNodeId, String toNodeId,
&nbsp;				boolean directed) {
<b class="nc">&nbsp;			wrappedElement.edgeAdded(sourceId, timeId, edgeId, fromNodeId, toNodeId, directed);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void edgeRemoved(String sourceId, long timeId, String edgeId) {
<b class="nc">&nbsp;			wrappedElement.edgeRemoved(sourceId, timeId, edgeId);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void graphCleared(String sourceId, long timeId) {
<b class="nc">&nbsp;			wrappedElement.graphCleared(sourceId, timeId);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void nodeAdded(String sourceId, long timeId, String nodeId) {
<b class="nc">&nbsp;			wrappedElement.nodeAdded(sourceId, timeId, nodeId);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void nodeRemoved(String sourceId, long timeId, String nodeId) {
<b class="nc">&nbsp;			wrappedElement.nodeRemoved(sourceId, timeId, nodeId);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void stepBegins(String sourceId, long timeId, double step) {
<b class="nc">&nbsp;			wrappedElement.stepBegins(sourceId, timeId, step);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Node&gt; iterator() {
<b class="nc">&nbsp;			return nodes().iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class SynchronizedNode extends SynchronizedElement&lt;Node&gt; implements Node {
&nbsp;
&nbsp;		private final SynchronizedGraph sg;
&nbsp;		private final ReentrantLock elementLock;
&nbsp;
&nbsp;		SynchronizedNode(SynchronizedGraph sg, Node n) {
<b class="nc">&nbsp;			super(n);</b>
&nbsp;
<b class="nc">&nbsp;			this.sg = sg;</b>
<b class="nc">&nbsp;			this.elementLock = new ReentrantLock();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Node&gt; neighborNodes() {
&nbsp;			List&lt;Node&gt; nodes;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				nodes = wrappedElement.neighborNodes().map(n -&gt; sg.getNode(n.getIndex())).collect(Collectors.toList());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return nodes.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Edge&gt; edges() {
&nbsp;			List&lt;Edge&gt; edges;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
&nbsp;
<b class="nc">&nbsp;				edges = wrappedElement.edges().map(e -&gt; sg.getEdge(e.getIndex())).collect(Collectors.toList());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return edges.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Edge&gt; leavingEdges() {
&nbsp;			List&lt;Edge&gt; edges;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
&nbsp;
<b class="nc">&nbsp;				edges = wrappedElement.leavingEdges().map(e -&gt; sg.getEdge(e.getIndex())).collect(Collectors.toList());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return edges.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Stream&lt;Edge&gt; enteringEdges() {
&nbsp;			List&lt;Edge&gt; edges;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
&nbsp;
<b class="nc">&nbsp;				edges = wrappedElement.enteringEdges().map(e -&gt; sg.getEdge(e.getIndex())).collect(Collectors.toList());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return edges.stream();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Node&gt; getBreadthFirstIterator() {
<b class="nc">&nbsp;			return getBreadthFirstIterator(false);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Node&gt; getBreadthFirstIterator(boolean directed) {
<b class="nc">&nbsp;			LinkedList&lt;Node&gt; l = new LinkedList&lt;Node&gt;();</b>
&nbsp;			Iterator&lt;Node&gt; it;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
&nbsp;
<b class="nc">&nbsp;				it = wrappedElement.getBreadthFirstIterator(directed);</b>
&nbsp;
<b class="nc">&nbsp;				while (it.hasNext())</b>
<b class="nc">&nbsp;					l.add(sg.getNode(it.next().getIndex()));</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return l.iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getDegree() {
&nbsp;			int d;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				d = wrappedElement.getDegree();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return d;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Node&gt; getDepthFirstIterator() {
<b class="nc">&nbsp;			return getDepthFirstIterator(false);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Node&gt; getDepthFirstIterator(boolean directed) {
<b class="nc">&nbsp;			LinkedList&lt;Node&gt; l = new LinkedList&lt;Node&gt;();</b>
&nbsp;			Iterator&lt;Node&gt; it;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				it = wrappedElement.getDepthFirstIterator();</b>
&nbsp;
<b class="nc">&nbsp;				while (it.hasNext())</b>
<b class="nc">&nbsp;					l.add(sg.getNode(it.next().getIndex()));</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return l.iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdge(int i) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdge(i).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEnteringEdge(int i) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEnteringEdge(i).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getLeavingEdge(int i) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getLeavingEdge(i).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeBetween(String id) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeBetween(id).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeBetween(Node n) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeBetween(n).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeBetween(int index) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeBetween(index).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeFrom(String id) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeFrom(id).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeFrom(Node n) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeFrom(n).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeFrom(int index) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeFrom(index).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeToward(String id) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeToward(id).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeToward(Node n) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeToward(n).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Edge getEdgeToward(int index) {
&nbsp;			Edge e;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				e = sg.getEdge(wrappedElement.getEdgeToward(index).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return e;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Graph getGraph() {
<b class="nc">&nbsp;			return sg;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getInDegree() {
&nbsp;			int d;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				d = wrappedElement.getInDegree();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return d;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getOutDegree() {
&nbsp;			int d;
&nbsp;
<b class="nc">&nbsp;			elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				d = wrappedElement.getOutDegree();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return d;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Edge&gt; iterator() {
<b class="nc">&nbsp;			return edges().iterator();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class SynchronizedEdge extends SynchronizedElement&lt;Edge&gt; implements Edge {
&nbsp;
&nbsp;		final SynchronizedGraph sg;
&nbsp;
&nbsp;		SynchronizedEdge(SynchronizedGraph sg, Edge e) {
<b class="nc">&nbsp;			super(e);</b>
<b class="nc">&nbsp;			this.sg = sg;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getNode0() {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = sg.getNode(wrappedElement.getNode0().getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getNode1() {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = sg.getNode(wrappedElement.getNode1().getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getOpposite(Node node) {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			if (node instanceof SynchronizedNode)</b>
<b class="nc">&nbsp;				node = ((SynchronizedNode) node).wrappedElement;</b>
&nbsp;
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = sg.getNode(wrappedElement.getOpposite(node).getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getSourceNode() {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = sg.getNode(wrappedElement.getSourceNode().getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Node getTargetNode() {
&nbsp;			Node n;
&nbsp;
<b class="nc">&nbsp;			sg.elementLock.lock();</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				n = sg.getNode(wrappedElement.getTargetNode().getIndex());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				sg.elementLock.unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return n;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isDirected() {
<b class="nc">&nbsp;			return wrappedElement.isDirected();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isLoop() {
<b class="nc">&nbsp;			return wrappedElement.isLoop();</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-07-08 16:57</div>
</div>
</body>
</html>
